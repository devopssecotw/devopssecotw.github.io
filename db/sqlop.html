<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.2.0/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.7.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.2.7"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.2.0/dist/index.umd.min.js"></script><script>(r => {
                setTimeout(r);
              })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, data) => {
        const {
          Markmap
        } = getMarkmap();
        window.mm = Markmap.create('svg#mindmap', getOptions == null ? void 0 : getOptions(), data);
      })(() => window.markmap,null,{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"Devopssec","c":[{"t":"heading","d":2,"p":{"lines":[1,2]},"v":"databases","c":[{"t":"heading","d":3,"p":{"lines":[2,3]},"v":"Oracle CS","c":[{"t":"heading","d":4,"p":{"lines":[3,4]},"v":"part 6","c":[{"t":"bullet_list","d":5,"p":{"lines":[4,7]},"v":"","c":[{"t":"list_item","d":6,"p":{"lines":[4,6]},"v":"PL/SQL stands for Procedural Language extensions to SQL (Structured Query Language). It was created by Oracle in order to overcome the disadvantages of SQL for easier building and handling of critical applications in a comprehensive manner.<br>\nFollowing are the disadvantages of SQL:"}]},{"t":"ordered_list","d":5,"p":{"lines":[12,15],"start":1},"v":"","c":[{"t":"list_item","d":6,"p":{"lines":[12,14],"index":1},"v":"1. What are the features of PL/SQL?<br>\nFollowing are the features of PL/SQL:"}]},{"t":"ordered_list","d":5,"p":{"lines":[21,40],"start":2},"v":"","c":[{"t":"list_item","d":6,"p":{"lines":[21,24],"index":2},"v":"2. What do you understand by PL/SQL table?<br>\nPL/SQL tables are nothing but objects of type tables that are modeled as database tables. They are a way to provide arrays that are nothing but temporary tables in memory for faster processing.<br>\nThese tables are useful for moving bulk data thereby simplifying the process"},{"t":"list_item","d":6,"p":{"lines":[24,37],"index":3},"v":"3. Explain the basic structure followed in PL/SQL?<br>\nThe basic structure of PL/SQL follows the BLOCK structure. Each PL/SQL code comprises SQL and PL/SQL statement that constitutes a PL/SQL block.<br>\nEach PL/SQL block consists of 3 sections:<br>\nThe optional Declaration Section<br>\nThe mandatory Execution Section<br>\nThe optional Exception handling Section<br>\n[DECLARE]<br>\n--declaration statements (optional)<br>\nBEGIN<br>\n--execution statements<br>\n[EXCEPTION]<br>\n--exception handling statements (optional)<br>\nEND;"},{"t":"list_item","d":6,"p":{"lines":[37,40],"index":4},"v":"4. What is a PL/SQL cursor?<br>\nA PL/SQL cursor is nothing but a pointer to an area of memory having SQL statements and the information of statement processing. This memory area is called a context area. This special area makes use of a special feature called cursor for the purpose of retrieving and processing more than one row.<br>\nIn short, the cursor selects multiple rows from the database and these selected rows are individually processed within a program."}]},{"t":"bullet_list","d":5,"p":{"lines":[40,70]},"v":"","c":[{"t":"list_item","d":6,"p":{"lines":[40,48]},"v":"There are two types of cursors:<br>\nImplicit Cursor:<br>\nOracle automatically creates a cursor while running any of the commands - SELECT INTO, INSERT, DELETE or UPDATE implicitly.<br>\nThe execution cycle of these cursors is internally handled by Oracle and returns the information and status of the cursor by making use of the cursor attributes- ROWCOUNT, ISOPEN, FOUND, NOTFOUND.<br>\nExplicit Cursor:<br>\nThis cursor is a SELECT statement that was declared explicitly in the declaration block.<br>\nThe programmer has to control the execution cycle of these cursors starting from OPEN to FETCH and close.<br>\nThe execution cycle while executing the SQL statement is defined by Oracle along with associating a cursor with it."},{"t":"list_item","d":6,"p":{"lines":[48,50]},"v":"Explicit Cursor Execution Cycle:<br>\nDue to the flexibility of defining our own execution cycle, explicit cursors are used in many instances. The following diagram represents the execution flow of an explicit cursor:"},{"t":"list_item","d":6,"p":{"lines":[50,54]},"v":"Cursor Declaration:<br>\nThe first step to use an explicit cursor is its declaration.<br>\nDeclaration can be done in a package or a block.<br>\nSyntax: CURSOR cursor_name IS query; where cursor_name is the name of the cursor, the query is the query to fetch data from any table."},{"t":"list_item","d":6,"p":{"lines":[54,59]},"v":"Open Cursor:<br>\nBefore the process of fetching rows from cursor, the cursor has to be opened.<br>\nSyntax to open a cursor: OPEN cursor_name;<br>\nWhen the cursor is opened, the query and the bind variables are parsed by Oracle and the SQL statements are executed.<br>\nThe execution plan is determined by Oracle and the result set is determined after associating the cursor parameters and host variables and post these, the cursor is set to point at the first row of the result set."},{"t":"list_item","d":6,"p":{"lines":[59,63]},"v":"Fetch from cursor:<br>\nFETCH statement is used to place the content of the current row into variables.<br>\nSyntax: FETCH cursor_name INTO variable_list;<br>\nIn order to get all the rows of a result set, each row needs to be fetched."},{"t":"list_item","d":6,"p":{"lines":[63,70]},"v":"Close Cursor:<br>\nOnce all the rows are fetched, the cursor needs to be closed using the CLOSE statement.<br>\nSyntax: CLOSE cursor_name;<br>\nThe instructions tell Oracle to release the memory allocated to the cursor.<br>\nCursors declared in procedures or anonymous blocks are by default closed post their execution.<br>\nCursors declared in packages need to be closed explicitly as the scope is global.<br>\nClosing a cursor that is not opened will result in INVALID_CURSOR exception"}]},{"t":"ordered_list","d":5,"p":{"lines":[70,98],"start":5},"v":"","c":[{"t":"list_item","d":6,"p":{"lines":[70,74],"index":5},"v":"5. What is the use of WHERE CURRENT OF in cursors?<br>\nWe use this clause while referencing the current row from an explicit cursor. This clause allows applying updates and deletion of the row currently under consideration without explicitly referencing the row ID.<br>\nSyntax:<br>\nUPDATE table_name SET field=new_value WHERE CURRENT OF cursor_name"},{"t":"list_item","d":6,"p":{"lines":[74,87],"index":6},"v":"6. How can a name be assigned to an unnamed PL/SQL Exception Block?<br>\nThis can be done by using Pragma called EXCEPTION_INIT.<br>\nThis gives the flexibility to the programmer to instruct the compiler to provide custom error messages based on the business logic by overriding the pre-defined messages during the compilation time.<br>\nSyntax:<br>\nDECLARE<br>\nexception_name EXCEPTION;<br>\nPRAGMA EXCEPTION_INIT (exception_name, error_code);<br>\nBEGIN<br>\n// PL/SQL Logic<br>\nEXCEPTION<br>\nWHEN exception_name THEN<br>\n// Steps to handle exception<br>\nEND;"},{"t":"list_item","d":6,"p":{"lines":[87,97],"index":7},"v":"7. What is a Trigger? Name some instances when “Triggers” can be used.<br>\nAs the name indicates, ‘Trigger’ means to ‘activate’ something. In the case of PL/SQL, a trigger is a stored procedure that specifies what action has to be taken by the database when an event related to the database is performed<br>\nSyntax:<br>\nTRIGGER trigger_name<br>\ntrigger_event<br>\n[ restrictions ]<br>\nBEGIN<br>\nactions_of_trigger;<br>\nEND;<br>\nIn the above syntax, if the trigger_name the trigger is in the enabled state, the trigger_event causes the database to fire actions_of_trigger if the restrictions are TRUE or unavailable."}]},{"t":"ordered_list","d":5,"p":{"lines":[105,115],"start":8},"v":"","c":[{"t":"list_item","d":6,"p":{"lines":[105,107],"index":8},"v":"8. When does a DECLARE block become mandatory?<br>\nThis statement is used by anonymous blocks of PL/SQL such as non-stored and stand-alone procedures. When they are being used, the statement should come first in the stand-alone file"},{"t":"list_item","d":6,"p":{"lines":[107,114],"index":9},"v":"9. How do you write comments in a PL/SQL code?<br>\nComments are those sentences that have no effect on the functionality and are used for the purpose of enhancing the readability of the code. They are of two types:<br>\nSingle Line Comment: This can be created by using the symbol -- and writing what we want to mention as a comment next to it.<br>\nMulti-Line comment: These are the comments that can be specified over multiple lines and the syntax goes like /* comment information */<br>\nExample:<br>\nSET SERVEROUTPUT ON;<br>\nDECLARE"}]},{"t":"ordered_list","d":5,"p":{"lines":[128,134],"start":10},"v":"","c":[{"t":"list_item","d":6,"p":{"lines":[128,130],"index":10},"v":"10. What is the purpose of WHEN clause in the trigger?<br>\nWHEN clause specifies for what condition the trigger has to be triggered."},{"t":"list_item","d":6,"p":{"lines":[131,133],"index":11},"v":"11. Can you explain the PL/SQL execution architecture?<br>\nThe PL/SQL engine does the process of compilation and execution of the PL/SQL blocks and programs and can only work if it is installed on an Oracle server or any application tool that supports Oracle such as Oracle Forms."}]},{"t":"bullet_list","d":5,"p":{"lines":[134,141]},"v":"","c":[{"t":"list_item","d":6,"p":{"lines":[134,137]},"v":"PL/SQL is one of the parts of Oracle RDBMS, and it is important to know that most of the Oracle applications are developed using the client-server architecture. The Oracle database forms the server-side and requests to the database form a part of the client-side.<br>\nSo based on the above fact and the fact that PL/SQL is not a standalone programming language, we must realize that the PL/SQL engine can reside in either the client environment or the server environment. This makes it easy to move PL/SQL modules and sub-programs between server-side and client-side applications.<br>\nBased on the architecture shown below, we can understand that PL/SQL engine plays an important role in the process and execute the PL/SQL statements and whenever it encounters the SQL statements, they are sent to the SQL Statement Processor."},{"t":"list_item","d":6,"p":{"lines":[137,141]},"v":"Case 1: PL/SQL engine is on the server: In this case, the whole PL/SQL block gets passed to the PL/SQL engine present on the Oracle server which is then processed and the response is sent.<br>\nCase 2: PL/SQL engine is on the client: Here the engine lies within the Oracle Developer tools and the processing of the PL/SQL statements is done on the client-side.<br>\nIn case, there are any SQL statements in the PL/SQL block, then they are sent to the Oracle server for SQL processing.<br>\nWhen there are no SQL statements, then the whole block processing occurs at the client-side"}]},{"t":"ordered_list","d":5,"p":{"lines":[141,288],"start":12},"v":"","c":[{"t":"list_item","d":6,"p":{"lines":[141,153],"index":12},"v":"12. Why is SYSDATE and USER keywords used?<br>\nSYSDATE:<br>\nThis keyword returns the current time and date on the local database server.<br>\nThe syntax is SYSDATE.<br>\nIn order to extract part of the date, we use the TO_CHAR function on SYSDATE and specify the format we need.<br>\nUsage:<br>\nSELECT SYSDATE FROM dual;<br>\nSELECT id, TO_CHAR(SYSDATE, 'yyyy/mm/dd') from InterviewBitEmployeeTable where customer_id &lt; 200;<br>\nUSER:<br>\nThis keyword returns the user id of the current session.<br>\nUsage:<br>\nSELECT USER FROM dual;"},{"t":"list_item","d":6,"p":{"lines":[153,158],"index":13},"v":"13. Differentiate between implicit cursor and explicit cursor.<br>\nImplicit Cursor     Explicit Cursor<br>\nAn implicit cursor is used when a query returns a single row value. When a subquery returns more than one row, an explicit cursor is used. These rows are called Active Set.<br>\nThis is used for all DML operations like DECLARE, OPEN, FETCH, CLOSE.   This is used to process Multirow SELECT Statements.<br>\nNO_DATA_FOUND Exception is handled here.    NO_DATA_FOUND cannot be handled here."},{"t":"list_item","d":6,"p":{"lines":[158,164],"index":14},"v":"14. Differentiate between SQL and PL/SQL.<br>\nSQL PL/SQL<br>\nSQL is a natural language meant for the interactive processing of data in the database. PL/SQL is a procedural extension of SQL.<br>\nDecision-making and looping are not allowed in SQL. PL/SQL supports all features of procedural language such as conditional and looping statements.<br>\nAll SQL statements are executed at a time by the database server which is why it becomes a time-consuming process.  PL/SQL statements are executed one block at a time thereby reducing the network traffic.<br>\nThere is no error handling mechanism in SQL.    This supports an error handling mechanism."},{"t":"list_item","d":6,"p":{"lines":[164,171],"index":15},"v":"15. What is the importance of %TYPE and %ROWTYPE data types in PL/SQL?<br>\n%TYPE: This declaration is used for the purpose of anchoring by providing the data type of any variable, column, or constant. It is useful during the declaration of a variable that has the same data type as that of its table column.<br>\nConsider the example of declaring a variable named ib_employeeid which has the data type and its size same as that of the column employeeid in table ib_employee.<br>\nThe syntax would be : ib_employeeid ib_employee.employeeid%TYPE;<br>\n%ROWTYPE: This is used for declaring a variable that has the same data type and size as that of a row in the table. The row of a table is called a record and its fields would have the same data types and names as the columns defined in the table.<br>\nFor example: In order to declare a record named ib_emprecord for storing an entire row in a table called ib_employee, the syntax is:<br>\nib_emprecord ib_employee%ROWTYPE;"},{"t":"list_item","d":6,"p":{"lines":[172,195],"index":16},"v":"16. What are the various functions available for manipulating the character data?<br>\nThe functions that are used for manipulating the character data are called String Functions.<br>\nLEFT: This function returns the specified number of characters from the left part of a string.<br>\nSyntax: LEFT(string_value, numberOfCharacters).<br>\nFor example, LEFT(‘InterviewBit’, 9) will return ‘Interview’.<br>\nRIGHT: This function returns the defined number of characters from the right part of a string.<br>\nSyntax: RIGHT(string_value, numberOfCharacters)<br>\nFor example, RIGHT(‘InterviewBit’,3) would return ‘Bit’.<br>\nSUBSTRING: This function would select the data from a specified start position through the number of characters defined from any part of the string.<br>\nSyntax: SUBSTRING(string_value, start_position, numberOfCharacters)<br>\nFor example, SUBSTRING(‘InterviewBit’,2,4) would return ‘terv’.<br>\nLTRIM: This function would trim all the white spaces on the left part of the string.<br>\nSyntax: LTRIM(string_value)<br>\nFor example, LTRIM(’ InterviewBit’) will return ‘InterviewBit’.<br>\nRTRIM: This function would trim all the white spaces on the right part of the string.<br>\nSyntax: RTRIM(string_value)<br>\nFor example, RTRIM('InterviewBit ') will return ‘InterviewBit’.<br>\nUPPER: This function is used for converting all the characters to the upper case in a string.<br>\nSyntax: UPPER(string_variable)<br>\nFor example, UPPER(‘interviewBit’) would return ‘INTERVIEWBIT’.<br>\nLOWER: This function is used for converting all the characters of a string to lowercase.<br>\nSyntax: LOWER(string_variable)<br>\nFor example, LOWER(‘INterviewBit’) would return ‘interviewbit’."},{"t":"list_item","d":6,"p":{"lines":[195,198],"index":17},"v":"17. What is the difference between ROLLBACK and ROLLBACK TO statements in PL/SQL?<br>\nROLLBACK command is used for rolling back all the changes from the beginning of the transaction.<br>\nROLLBACK TO command is used for undoing the transaction only till a SAVEPOINT. The transactions cannot be rolled back before the SAVEPOINT and hence the transaction remains active even before the command is specified"},{"t":"list_item","d":6,"p":{"lines":[198,200],"index":18},"v":"18. What is the use of SYS.ALL_DEPENDENCIES?<br>\nSYS.ALL_DEPENDENCIES is used for describing all the dependencies between procedures, packages, triggers, functions that are accessible to the current user. It returns the columns like name, dependency_type, type, referenced_owner etc."},{"t":"list_item","d":6,"p":{"lines":[200,205],"index":19},"v":"19. What are the virtual tables available during the execution of the database trigger?<br>\nThe THEN and NOW tables are the virtual tables that are available during the database trigger execution. The table columns are referred to as THEN.column and NOW.column respectively.<br>\nOnly the NOW.column is available for insert-related triggers.<br>\nOnly the THEN.column values are available for the DELETE-related triggers.<br>\nBoth the virtual table columns are available for UPDATE triggers."},{"t":"list_item","d":6,"p":{"lines":[205,208],"index":20},"v":"20. Differentiate between the cursors declared in procedures and the cursors declared in the package specifications.<br>\nThe cursors that are declared in the procedures will have the local scope and hence they cannot be used by other procedures.<br>\nThe cursors that are declared in package specifications are treated with global scope and hence they can be used and accessed by other procedures"},{"t":"list_item","d":6,"p":{"lines":[208,220],"index":21},"v":"21. What are COMMIT, ROLLBACK and SAVEPOINT statements in PL/SQL?<br>\nThese are the three transaction specifications that are available in PL/SQL.<br>\nCOMMIT: Whenever any DML operations are performed, the data gets manipulated only in the database buffer and not the actual database. In order to save these DML transactions to the database, there is a need to COMMIT these transactions.<br>\nCOMMIT transaction action does saving of all the outstanding changes since the last commit and the below steps take place:<br>\nThe release of affected rows.<br>\nThe transaction is marked as complete.<br>\nThe details of the transaction would be stored in the data dictionary.<br>\nSyntax: COMMIT;<br>\nROLLBACK: In order to undo or erase the changes that were done in the current transaction, the changes need to be rolled back. ROLLBACK statement erases all the changes since the last COMMIT.<br>\nSyntax: ROLLBACK;<br>\nSAVEPOINT: This statement gives the name and defines a point in the current transaction process where any changes occurring before that SAVEPOINT would be preserved whereas all the changes after that point would be released.<br>\nSyntax: SAVEPOINT &lt;savepoint_name&gt;;"},{"t":"list_item","d":6,"p":{"lines":[220,224],"index":22},"v":"22. How can you debug your PL/SQL code?<br>\nWe can use DBMS_OUTPUT and DBMS_DEBUG statements for debugging our code:<br>\nDBMS_OUTPUT prints the output to the standard console.<br>\nDBMS_DEBUG prints the output to the log file."},{"t":"list_item","d":6,"p":{"lines":[224,227],"index":23},"v":"23. What is the difference between a mutating table and a constraining table?<br>\nA table that is being modified by the usage of the DML statement currently is known as a mutating table. It can also be a table that has triggers defined on it.<br>\nA table used for reading for the purpose of referential integrity constraint is called a constraining table."},{"t":"list_item","d":6,"p":{"lines":[227,233],"index":24},"v":"24. In what cursor attributes the outcomes of DML statement execution are saved?<br>\nThe outcomes of the execution of the DML statement is saved in the following 4 cursor attributes:<br>\nSQL%FOUND: This returns TRUE if at least one row has been processed.<br>\nSQL%NOTFOUND: This returns TRUE if no rows were processed.<br>\nSQL%ISOPEN: This checks whether the cursor is open or not and returns TRUE if open.<br>\nSQL%ROWCOUNT: This returns the number of rows processed by the DML statement"},{"t":"list_item","d":6,"p":{"lines":[233,237],"index":25},"v":"25. Is it possible to declare column which has the number data type and its scale larger than the precision? For example defining columns like: column name NUMBER (10,100), column name NUMBER (10,-84)<br>\nYes, these type of declarations are possible.<br>\nNumber (9, 12) indicates that there are 12 digits after decimal point. But since the maximum precision is 9, the rest are 0 padded like 0.000999999999.<br>\nNumber (9, -12) indicates there are 21 digits before the decimal point and out of that there are 9 possible digits and the rest are 0 padded like 999999999000000000000.0"},{"t":"list_item","d":6,"p":{"lines":[237,259],"index":26},"v":"26. Write a PL/SQL program using WHILE loop for calculating the average of the numbers entered by user. Stop the entry of numbers whenever the user enters the number 0.<br>\nDECLARE<br>\nn NUMBER;<br>\naverage NUMBER :=0 ;<br>\nsum NUMBER :=0 ;<br>\ncount NUMBER :=0 ;<br>\nBEGIN<br>\n-- Take input from user<br>\nn := &amp;input_number;<br>\nWHILE(n&lt;&gt;0)<br>\nLOOP<br>\n-- Increment count to find total elements<br>\ncount := count+1;<br>\n-- Sum of elements entered<br>\nsum := sum+n;<br>\n-- Take input from user<br>\nn := &amp;input_number;<br>\nEND LOOP;<br>\n-- Average calculation<br>\naverage := sum/count;<br>\nDBMS_OUTPUT.PUT_LINE(‘Average of entered numbers is ’||average);<br>\nEND;"},{"t":"list_item","d":6,"p":{"lines":[259,266],"index":27},"v":"27. Write a PL/SQL procedure for selecting some records from the database using some parameters as filters.<br>\nConsider that we are fetching details of employees from ib_employee table where salary is a parameter for filter.<br>\nCREATE PROCEDURE get_employee_details @salary nvarchar(30)<br>\nAS<br>\nBEGIN<br>\nSELECT * FROM ib_employee WHERE salary = @salary;<br>\nEND;"},{"t":"list_item","d":6,"p":{"lines":[266,287],"index":28},"v":"28. Write a PL/SQL code to count the number of Sundays between the two inputted dates.<br>\n--declare 2 dates of type Date<br>\nDECLARE<br>\nstart_date Date;<br>\nend_date Date;<br>\nsundays_count Number:=0;<br>\nBEGIN<br>\n-- input 2 dates<br>\nstart_date:='&amp;input_start_date';<br>\nend_date:='&amp;input_end_date';<br>\n/*<br>\nReturns the date of the first day after the mentioned date<br>\nand matching the day specified in second parameter.<br>\n*/<br>\nstart_date:=NEXT_DAY(start_date-1, 'SUNDAY');<br>\n--check the condition of dates by using while loop.<br>\nwhile(start_date&lt;=end_date)<br>\nLOOP<br>\nsundays_count:=sundays_count+1;<br>\nstart_date:=start_date+7;<br>\nEND LOOP;"}]},{"t":"ordered_list","d":5,"p":{"lines":[299,308],"start":29},"v":"","c":[{"t":"list_item","d":6,"p":{"lines":[299,307],"index":29},"v":"29. Write PL/SQL code block to increment the employee’s salary by 1000 whose employee_id is 102 from the given table below.<br>\nEMPLOYEE_ID FIRST_NAME  LAST_NAME   EMAIL_ID    PHONE_NUMBER    JOIN_DATE   JOB_ID  SALARY<br>\n100 ABC DEF abef    9876543210  2020-06-06  AD_PRES 24000.00<br>\n101 GHI JKL ghkl    9876543211  2021-02-08  AD_VP   17000.00<br>\n102 MNO     PQR mnqr    9876543212  2016-05-14  AD_VP   17000.00<br>\n103 STU VWX stwx    9876543213  2019-06-24  IT_PROG 9000.00<br>\nDECLARE<br>\nemployee_salary  NUMBER(8,2);"}]},{"t":"ordered_list","d":5,"p":{"lines":[334,411],"start":30},"v":"","c":[{"t":"list_item","d":6,"p":{"lines":[334,352],"index":30},"v":"30. Write a PL/SQL code to find whether a given string is palindrome or not.<br>\nDECLARE<br>\n-- Declared variables string, letter, reverse_string where string is the original string.<br>\nstring VARCHAR2(10) := 'abccba';<br>\nletter VARCHAR2(20);<br>\nreverse_string VARCHAR2(10);<br>\nBEGIN<br>\nFOR i IN REVERSE 1..LENGTH(string) LOOP<br>\nletter := SUBSTR(string, i, 1);<br>\n-- concatenate letter to reverse_string variable<br>\nreverse_string := reverse_string ||''||letter;<br>\nEND LOOP;<br>\nIF reverse_string = string THEN<br>\ndbms_output.Put_line(reverse_string||''||' is palindrome');<br>\nELSE<br>\ndbms_output.Put_line(reverse_string ||'' ||' is not palindrome');<br>\nEND IF;<br>\nEND;"},{"t":"list_item","d":6,"p":{"lines":[353,391],"index":31},"v":"31. Write PL/SQL program to convert each digit of a given number into its corresponding word format.<br>\nDECLARE<br>\n-- declare necessary variables<br>\n-- num represents the given number<br>\n-- number_to_word represents the word format of the number<br>\n-- str, len and digit are the intermediate variables used for program execution<br>\nnum   INTEGER;<br>\nnumber_to_word VARCHAR2(100);<br>\ndigit_str   VARCHAR2(100);<br>\nlen   INTEGER;<br>\ndigit   INTEGER;<br>\nBEGIN<br>\nnum := 123456;<br>\nlen := LENGTH(num);<br>\ndbms_output.PUT_LINE('Input: ' ||num);<br>\n-- Iterate through the number one by one<br>\nFOR i IN 1..len LOOP<br>\ndigit := SUBSTR(num, i, 1);<br>\n-- Using DECODE, get the str representation of the digit<br>\nSELECT Decode(digit, 0, 'Zero ',<br>\n1, 'One ',<br>\n2, 'Two ',<br>\n3, 'Three ',<br>\n4, 'Four ',<br>\n5, 'Five ',<br>\n6, 'Six ',<br>\n7, 'Seven ',<br>\n8, 'Eight ',<br>\n9, 'Nine ')<br>\nINTO digit_str<br>\nFROM dual;<br>\n-- Append the str representation of digit to final result.<br>\nnumber_to_word := number_to_word || digit_str;<br>\nEND LOOP;<br>\ndbms_output.PUT_LINE('Output: ' ||number_to_word);<br>\nEND;<br>\nInput: 12345<br>\nOutput: One Two Three Four Five"},{"t":"list_item","d":6,"p":{"lines":[392,411],"index":32},"v":"32. Write PL/SQL program to find the sum of digits of a number.<br>\nDECLARE<br>\n--Declare variables num, sum_of_digits and remainder of datatype Integer<br>\nnum  INTEGER;<br>\nsum_of_digits INTEGER;<br>\nremainder  INTEGER;<br>\nBEGIN<br>\nnum := 123456;<br>\nsum_of_digits := 0;<br>\n-- Find the sum of digits until original number doesnt become null<br>\nWHILE num &lt;&gt; 0 LOOP<br>\nremainder := MOD(num, 10);<br>\nsum_of_digits := sum_of_digits + remainder;<br>\nnum := TRUNC(num / 10);<br>\nEND LOOP;<br>\ndbms_output.PUT_LINE('Sum of digits is '|| sum_of_digits);<br>\nEND;<br>\nInput: 9874<br>\nOutput: 28"}]}]}]}]}]})</script>
</body>
</html>
