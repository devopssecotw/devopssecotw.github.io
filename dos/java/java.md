# dos
## java
### java.lang.
#### part 1
- 1. Java Terminology
     Let us quickly go through some of the most important terms used in the Java programming language.
- JVM: The JVM stands for Java Virtual Machine. A program’s execution is divided into three stages. A Java program is written, compiled and then run.
  As we can see in the above image, first the JVM language classes are processed by the class loader subsystem which is responsible for 
- loading, linking and initialization of the java classes. After being processed by the class loader, the generated files are stored in the 
- JVM Memory which consists of method area, heap, JVM language stacks, PC registers and native method stacks. The execution engine accesses the files from this JVM memory and makes use of the Native Method Interface and Native Method Libraries.

A Java programmer creates a program.
The JAVAC compiler, which is a primary Java compiler provided in the Java development kit (JDK), is used to compile the code. It accepts a Java application as input and outputs bytecode.
JVM runs the bytecode generated by the compiler during the program’s Running phase.
The Java Virtual Machine’s job is to run the bytecode generated by the compiler. Although each operating system has its own JVM, the output they provide after bytecode execution is consistent across all of them. Java is known as a platform-independent language for this reason.

Bytecode: Bytecode is a type of intermediate code generated by the compiler after source code has been compiled (JAVA Program). Java is a platform-independent language thanks to this intermediate code.

- JRE: The Java Runtime Environment (JRE) is included with the JDK. The JRE installation on our computers allows us to run the Java program, but we cannot compile it. A browser, JVM, applet support, and plugins are all included in JRE. JRE is required for a computer to run a Java program.
JVM together with the Java Class Libraries makes up the JRE.

- Java Development Kit (JDK): When we learn about bytecode and JVM, we use the name JDK. As the name implies, it is a complete Java development kit that includes everything from the compiler to the Java Runtime Environment (JRE), debuggers, and documentation. In order to design, compile, and run the java application, we must first install JDK on our computer.
 JRE when combined with Development Tools makes up JDK.

- Garbage Collection: Garbage collection is the technique through which Java programs maintain their memory automatically. Java programs are compiled into bytecode that may be executed by a Java Virtual Machine, or JVM. Objects are produced on the heap, which is a part of memory devoted to the Java application, while it runs on the JVM. Some objects will become obsolete over time. To free up memory, the garbage collector detects these useless objects and deletes them.

- finalize method: It’s a method that the Garbage Collector calls shortly before deleting or destroying an object that’s suitable for Garbage Collection in order to do cleanup. Clean-up activity entails de-allocating or closing the resources associated with that object, such as Database Connections and Network Connections. It’s important to remember that it’s not a reserved keyword. Garbage Collector destroys the object as soon as the finalise method completes. The finalise method is found in the Object class and has the following syntax: protected void finalize throws Throwable{}

Since the finalize function is contained in the Object class and Object is the superclass of all Java classes, the finalize method is available to all Java classes. As a result, the garbage collector may invoke the finalise function on any java object. We must override the finalize method present in the Object class to specify our own clean-up activities since the finalize function in the Object class has an empty implementation

2. Java Basics
- object - An object is an entity with state and behaviour, such as a chair, a bike, a marker, a pen, a table, a car, and so on. It could be either physical or logical (tangible or intangible). The financial system is an example of an intangible object
- three characteristics of an object
State: The data (value) of an object is represented by its state.
Behaviour: The functionality of an object, such as deposit, withdrawal, and so on, is represented by the term behaviour.
Identity: A unique ID is often used to represent an object’s identification. The value of the ID is hidden from the outside user. The JVM uses it internally to uniquely identify each object.
- class - A class is a collection of objects with similar attributes. It’s a blueprint or template from which objects are made. It’s a logical thing. It can’t be physical. In Java, a class definition can have the following elements:
Modifiers: A class can be private or public, or it can also have a default access level
class keyword: To construct a class, we use the class keyword.
class name: The name of the class should usually start with a capital letter.
Superclass (optional): If the class has any superclass, we use the extends keyword and we mention the name of the superclass after the class name.
Interface (optional): If the class implements an interface, we use the implements keyword followed by the name of the interface after the class name.
- Constructors: A constructor in Java is a block of code that is comparable to a method. When a new instance of the class is created, the constructor is invoked. It is only when the constructor is invoked that memory for the object is allocated.
- 
  ```
      keyword - Reserved words are another name for Java keywords. Keywords are specific terms that have special meanings. Because these are Java’s predefined words, they can’t be used as variable, object, or class names. Following is the list of keywords used in Java:-
    Keyword	Use Case
    boolean	The boolean keyword in Java is used to declare a variable to be of the boolean type. It can only store True and False values.
    byte	The byte keyword in Java is used to create a variable that can handle 8-bit data values.
    break	The break keyword in Java is used to end a loop or switch statement. It interrupts the program’s current flow when certain circumstances are met.
    abstract	The abstract keyword in Java is used to declare an abstract class.
    case	The case keyword in Java is used with switch statements to mark text blocks.
    try	The try keyword in Java is used to begin a block of code that will be checked for errors. Either a catch or a finally block must come after the try block.
    short	The Java short keyword is used to declare a variable with a 16-bit integer capacity.
    void	The void keyword in Java is used to indicate that a method has no return value.
    static	The static keyword is used to denote a class method or a class variable in Java.
    synchronized	In multithreaded programming, the synchronized keyword is used to designate the critical sections or functions.
    super	The super keyword in Java is a reference variable that refers to parent class objects. It can be used to call the method of the immediate parent class.
    volatile	The volatile keyword in Java is used to signal that a variable might change asynchronously.
    while	The while keyword in Java is used to initiate a while loop. This loop repeats a section of the program many times. The while loop is recommended if the number of iterations is not predetermined.
    catch	The catch keyword in Java is used to capture exceptions thrown by try statements. It can only be used after the try block.
    char	Declare a variable that can hold unsigned 16-bit Unicode characters with the char keyword.
    class	To declare a class in Java, use the class keyword.
    continue	The continue keyword in Java is used to keep the loop going by continuing the program’s current flow while skipping the remaining code at the specified circumstance.
    default	The default keyword in Java can be used to define a default block of code in a switch statement. It can also be used as a default access modifier.
    do	The do keyword in Java is used to declare a loop in the control statement. It can repeat a section of the program multiple times.
    double	The double keyword in Java is used to create a variable that can hold a 64-bit floating-point number.
    else	In an, if statement, the else keyword in Java is used to represent alternate branches.
    enum	The enum keyword in Java is used to specify a set of fixed constants.
    extends	The extends keyword in Java is used to show that a class is inherited from another class or interface.
    final	
    The final keyword in Java can be used with variables, methods and classes. 
    When used with a variable, the value of the variable becomes constant. Any modifications in the variable’s value at a later stage leads to a compilation error.
    When used with a method, the method cannot be overridden in the classes that extend the given class.
    When used with a class, the class becomes noninheritable.
    finally	In a try-catch structure, the finally keyword denotes a code block. Whether or not an exception is handled, this block is always run.
    float	The float keyword in Java is used to create a variable that can carry a 32-bit floating-point value.
    for	The for keyword in Java is used to begin a for loop. When a condition is met, it is used to repeatedly execute a set of instructions/functions.
    if	The if keyword in Java is used to test a condition. If the condition is true, the if block is executed.
    implements	The keyword implements is used in Java to implement an interface.
    import	The import keyword in Java makes classes and interfaces available to the current source code.
    throw	The throw keyword in Java is used to throw an exception explicitly. Throwing custom exceptions is the most common use of the throw keyword.
    this	The this keyword is used to refer to the current object in the method or the constructor of the class.
    throws	The throws keyword in Java is used to declare an exception. throws can be used to propagate checked exceptions.
    instanceof	The instanceof keyword in Java is used to determine whether an object is an instance of a given class or implements an interface.
    int	The int keyword in Java is used to declare a variable that can hold a signed 32-bit integer.
    interface	The interface keyword in Java is used to declare an interface.
    long	The long keyword in Java is used to specify a variable that may store a 64-bit integer.
    native	The Java native keyword indicates that a method is implemented using JNI (Java Native Interface) in native code.
    new	The new keyword in Java is used to create new objects.
    null	The null keyword in Java is used to indicate that a reference refers to nothing.
    private	The private keyword in Java is an access modifier. It’s used to say that a method or variable can only be accessible in the class where it’s declared.
    protected	The protected keyword in Java is an access modifier. It can be accessed both within and outside the package, but only through inheritance.
    public	The public keyword in Java is an access modifier. It’s a term meaning anything can be found anyplace. Among all the modifiers, it has the broadest application.
    return	When a method’s execution is complete, the Java return keyword is used to exit the method.
  ```
3. Variables in Java
- Types of variables:
Local variable - A local variable is a variable defined within a block, method, or constructor. These variables have a scope that is limited to the block in which they are defined. i.e., these variables are only accessible within that block.
Instance variable - Variables that are declared inside a class without the ‘static’ keyword are referred to as instance variables. Instance variables are replicated for every object of the class being created.
Static variable - Variables that are declared inside a class with the ‘static’ keyword are referred to as static variables. Static variables are shared by all the objects of the class and are not replicated. Static variables are created at the start of program execution and automatically destroyed when the program is finished. It is not necessary to initialise a static variable. It has a value of 0 by default.

4. Datatypes in Java
- Primitive Data Types
- 
  ```
      Data Type	Default Size	Description
    boolean	1 bit	Only two potential values are stored in the Boolean data type: true and false. Simple flags that track true/false circumstances are stored in this data type.
    char	2 byte	A single 16-bit Unicode character is represented by the char data type. It has a value range of ‘\u0000’ (or 0) to ‘\uffff’ (or 65,535 inclusive).
    byte	1 byte	It’s an 8-bit two-s complement signed integer. It has a value range of -128 to 127. (inclusive). It has a value of 0 by default. The byte data type is used to preserve memory in huge arrays where space is at a premium. Because a byte is four times smaller than an integer, it saves space.
    short	2 bytes	A 16-bit signed two’s complement integer is the short data type. It has a value range of -32,768 to 32,767. (inclusive). It has a value of 0 by default.
    int	4 bytes	A 32-bit signed two’s complement integer is represented by the int data type. Its range of values is (-2^31) to (2^31 -1)(inclusive).
    long	8 bytes	A 64-bit two’s complement integer is the long data type. It has a value range of (-2^63) to (2^63 -1)(inclusive).
    float	4 bytes	The float data type is a 32-bit IEEE 754 floating-point with single precision. If you need to preserve memory in big arrays of floating point integers, use a float (rather than a double).
    double	8 bytes	A double data type is a 64-bit IEEE 754 floating-point with double precision. Like float, the double data type is commonly used for decimal values. For precise values, such as currency, the double data type should never be utilised. 0.0d is the default value.
  ```

#### part 2
5. Java Keywords
- a) Understanding the this keyword in Java:
this: to refer to the current instance variable of the class
this: to call the method of the current class
this() is used to call the constructor of the current class
this: to use as a parameter in a method
this keyword can be used to get the current instance of a class
- b) final keyword in Java:
Final Variables:
Final Classes:
Final Methods:
- c) static keyword in Java:
Static Blocks:
Static Variables:
Static Methods:
Static Classes:
- d) super keyword in Java: 
Using super with variables:
Using super with methods:

6. Java Comments
- Single line comments:  // 
- Multiline comments: /**/
- JavaDoc:/** */

7. Access Modifiers in Java
- private: A private modifier’s access level is restricted to members of the class. It isn’t accessible outside of the class.
  default: A default modifier’s access level is limited to the package. It’s not possible to get to it from outside the package. If you don’t indicate an access level, the default will be used.
  protected: A protected modifier’s access level is both within and outside the package via a child class.
  public: A public modifier’s access level is universal. It can be accessed from within and outside the class, and from within and outside the package.
8. Operators in Java
-     Operator Type	Description	Operators
  Unary Operators	Only one operand is required for unary operators. They are used to increase, decrease, or negate a value.	++, --, +, -, !
  Arithmetic Operators	Simple arithmetic operations on primitive data types are performed with them.	+, – , *, / , %
  Assignment Operators	The assignment operator is used to give any variable a value. It has right-to-left associativity, which means that the value given on the right-hand side of the operator is assigned to the variable on the left. As a result, the right-hand side value must be declared before use or be a constant.	=, +=, -=, *=, /=, %=, &=, ^=,
  Relational Operators	These operators are used to verify for equality, greater than, and less than relationships. They return a boolean result following comparison and are frequently used in looping and conditional if-else statements.	>, <, >=, <=, ==, !=
  Logical Operators	These operators conduct “logical AND” and “logical OR” operations, which are analogous to the AND and OR gates in digital electronics. One point to bear in mind is that if the first condition is false, the second condition is not examined, resulting in a short-circuiting effect. Used to test for a variety of variables before making a choice.	&&, ||
  Ternary Operator	The ternary operator is a condensed form of the if-else expression. The name ternary comes from the fact that it has three operands.	?:
  Bitwise Operators	These operators are used to manipulate the bits of a number individually. They can be applied to any integer type. They’re used to do Binary indexed tree updates and query operations.	&, |, ^
  Shift Operators	These operators shift the bits of a number to the left or right, multiplying or dividing it by two, accordingly. When we need to multiply or divide a number by two, we can use them.	<<, >>, >>>

- Precedence and Associativity of operators in Java
  Operators	Associativity	Type
  ++, –	Right to Left	Unary postfix
  ++, --, +, -, !	Right to Left	Unary prefix
  /, *, %	Left to Right	Multiplicative
  +, -	Left to Right	Additive
  <, <=, >, >=	Left to Right	Relational
  ==, !==	Left to Right	Equality
  &	Left to Right	Boolean Logical AND
  ^	Left to Right	Boolean Logical Exclusive OR
  |	Left to Right	Boolean Logical Inclusive OR
  &&	Left to Right	Conditional AND
  ||	Left to Right	Conditional OR
  ?:	Right to Left	Conditional
  =, +=, -=, *=, /=, %=	Right to Left	Assignment

9. Identifiers in Java
   Rules for defining Java identifiers:-

A proper Java identifier must follow certain guidelines. If we don’t follow these guidelines, we’ll get a compile-time error. These criteria apply to other languages as well, such as C and C++.
All alphanumeric characters ([A-Z],[a-z],[0-9]), ‘$’ (dollar symbol), and ‘_’ are the only characters that can be used as identifiers (underscore). For example, “bit@” is not an acceptable Java identifier because it contains the special character ‘@,’.
Numbers should not be used to begin identifiers ([0-9]). “123geeks,” for example, is not a valid Java identifier.
Case matters when it comes to Java Identifiers. For example ‘bit’ and ‘BIT’ would be considered as different identifiers in Java.
The length of the identifier is not limited, however, it is recommended that it be kept to a maximum of 4–15 letters.
Reserved Words aren’t allowed to be used as identifiers. Because while is a reserved term, “int while = 20;” is an incorrect sentence. In Java, there are 53 reserved terms.
The length of the identifier is not limited, however, it is recommended that it be kept to a maximum of 4–15 letters.
Reserved words: 

10. Control Flow in Java
- Decision-Making Statements:
- If Statement / if-else / if-else-if ladder / Nested if-statement
- Switch Statement
- Loop Statements: For Loop / While Loop / Do While Loop
- Jump Statements: break statement / continue statement

11. Java Packages
- Built-in Packages:
- java.lang: This package contains language-specific classes (e.g classes that define primitive data types, maths operations). This package will be imported automatically.
  java.io: This package contains classes that handle input and output operations.
  java.util: This package contains utility classes that provide data structures such as Linked Lists, Dictionary, and Date/Time operations.
  java.applet: This package contains Applet-related classes.
  java.awt: Contains classes for implementing graphical user interface components (like buttons, menus etc).
  java.net: This package contains classes that help with networking

12. Java Methods
    Method Declaration:- Method properties such as visibility, return type, name, and parameters are all stated in the method declaration. As seen in the following diagram, it consists of six components known as method headers.
    Method signature - A method signature is a statement that identifies a method. It’s included in the method declaration. It contains the method name as well as a list of parameters.

- Access Specifier - The method’s access specifier, also known as a modifier, determines the method’s access type. It specifies the method’s visibility. There are four different types of access specifiers in Java:
public: When we utilise the public specifier in our application, all classes can access the method.
private: The method is only accessible in the classes in which it is declared when we use a private access specifier.
protected: The method is accessible within the same package or subclasses in a different package when we use the protected access specifier.
default: When no access specifier is specified in the method declaration, Java uses the default access specifier. It can only be seen from the same package.
- Return Type - The data type that the method returns is known as the return type. It could be a primitive data type, an object, a collection, or void, for example. The void keyword is used when a method does not return anything.
- Method name - The name of a method is defined by its method name, which is a unique name. It must be appropriate for the method’s functionality. If we’re making a method for subtracting two numbers, the name of the method must be subtraction (). The name of a method is used to call it.
- Parameter List - The parameter list is a collection of parameters separated by a comma and wrapped in parentheses. It specifies the data type as well as the name of the variable. Leave the parenthesis blank if the method has no parameters.
- Method body - The method declaration includes a section called the method body. It contains all of the actions that must be completed. It is protected by a pair of curly braces






#### part 3
13. Java Polymorphism
- Compile-time Polymorphism: Compile-time polymorphism is also known as static polymorphism. In Java, this is achieved by function overloading.
- Method Overloading: When there are numerous functions with the same name but distinct parameters, this is referred to as overloading. Changes in the number of arguments or the kind of arguments can cause functions to become overloaded.
-Runtime Polymorphism:
Runtime polymorphism, often known as Dynamic Method Dispatch, is a technique for resolving calls to overridden methods at runtime rather than at compile time. A superclass's reference variable is used to call an overridden method in this process. The object referred to by the reference variable is used to determine which method should be called.

14. Java Inheritance
    Subclasses/Child Classes: A subclass is a class that inherits from another. A derived class, extended class, or kid class is another name for it.
    Superclasses: A superclass (sometimes known as a parent class) is the class from which a subclass derives its features. It's also known as a parent class or a base class.
- Types of inheritance in Java:

1. Single Inheritance - Subclasses inherit the features of a single superclass via single inheritance. Class A acts as a base class for the derived class B in the figure below.
2. Multilevel Inheritance - Multilevel Inheritance: In Multilevel Inheritance, a derived class inherits from a base class, and the derived class also serves as the base class for other classes. Class A serves as a base class for derived class B, which in turn serves as a base class for derived class C in the diagram below. In Java, a class cannot directly access the members of a grandparent.
3. Hierarchical Inheritance - One class serves as a superclass (base class) for several subclasses in Hierarchical Inheritance. Class A acts as a base class for the derived classes B, C, and D in the diagram below.
4. Multiple Inheritance - When a class inherits from more than one class, it is referred to as multiple inheritances. The below image shows class C inheriting from classes A and B.

Hybrid Inheritance - Hybrid Inheritance is a blend of two or more of the inheritance kinds listed above. The below figure shows two classes B and C inheriting from class A and a class D inheriting from both classes B and C.


15. Java Math Class
16. Abstract class and Interfaces
- some key points to remember about Java abstract classes.
An abstract class instance cannot be created.
The use of constructors is permitted.
There is no need for an abstract method in an abstract class.
Final methods aren't allowed in abstract classes since they can't be overridden, but abstract methods are designed to be overridden.
We are prohibited from creating objects for any abstract class.
In an abstract class, we can define static methods.

- Java Interfaces:-
An interface, like a class, can include methods and variables, but the methods declared in an interface are abstract by default (only method signature, no body).
Interfaces define what a class must do, not how it must do it.
An interface is about capabilities; for example, a Player may be an interface, and any class that implements it must be able to (or must implement) movement (). As a result, it provides a set of methods that must be implemented by the class.
If a class implements an interface but does not offer method bodies for all of the interface's functionalities, the class must be abstracted

-  Abstract Class vs Interface:
  The following table depicts the differences between abstract classes and interfaces in Java:
  Abstract Class	Interface
  Abstract and non-abstract methods can both be found in an abstract class. It can also contain default and static methods starting with Java 8.	An interface can only contain abstract methods.
  Non-final variables can be present in abstract classes.	Variables declared in a Java interface are by default final variables.
  Variables in an abstract class can be final, non-final, static, or non-static.	Only static and final variables are used in the interface.
  The interface can be implemented using an abstract class.	An abstract class cannot be implemented using an interface.
  The keyword "extends" can be used to extend an abstract class.	The keyword "implements" can be used to implement a Java interface.

17. Arrays in Java
    All arrays in Java are allocated dynamically. (explained further down)
    Because arrays are objects in Java, we may use the object attribute length to determine their length. This differs from C/C++, where we use sizeof to find the length.
    With [] following the data type, a Java array variable can be declared just like any other variable.
    The array’s variables are sorted, and each has an index starting at 0.
    An array’s size must be given using an int or short integer rather than a long number.
    Object is the array type’s direct superclass.
    Every array type implements the Cloneable and java.io.Serializable interfaces.

18. Strings in Java
    Strings are Objects in Java that are internally supported by a char array. Strings are immutable
-     String Buffer vs String Builder:
  The following table lists the differences between String Buffer and String Builder in Java:
  String Buffer	String Builder
  StringBuffer is thread-safe since it is synchronised. It means that two threads can’t execute the StringBuffer functions at the same time. If they call the StringBuffer function at the same time, only one of the two threads acquires the lock and executes the method. The second thread has to wait until the execution of the first thread has been completed.	StringBuilder is not thread-safe because it is not synchronised. It indicates that two threads can use StringBuilder’s methods at the same time. In this case, no thread has to wait for the execution of the other thread.
  String Buffer is considered to be less efficient than String Builder.	String Builder is considered to be more efficient than String Buffer.
  String Buffer was introduced in Java 1.0.	String Builder was introduced in Java 1.5.


#### part 4
19. Java Regex
    Regex (short for Regular Expressions) is a Java API for defining String patterns that may be used to search, manipulate, and modify strings

-    Class	Description
    util.regex.Pattern	It is used to define patterns.
    util.regex.Matcher	It is used to conduct match operations on text using patterns.
    PatternSyntaxException	In a regular expression pattern, it's used to indicate a syntax problem.

20. Java Exception Handling
    Meaning of Exception: An exception is an unwelcome or unexpected occurrence that occurs during the execution of a program, i.e. at run time, and disturbs the program's usual flow of instructions.
Error vs Exception: What is the Difference?
An error implies that there is a major problem that a reasonable programme should not attempt to solve whereas an exception denotes a set of circumstances that a reasonable programme would attempt to catch.
   
- Exceptions can be divided into two categories:
Checked Exceptions: This includes IO Exceptions and Compile time Exceptions.
Unchecked Exceptions: This includes Runtime Exceptions and Null Pointer Exceptions.
Built-in Exceptions in Java: Exceptions that are present in Java libraries are known as built-in exceptions. The following table lists the built-in exceptions in Java:

- Java Try-Catch
  try block: The try block comprises a set of statements that may throw an exception
  catch block: The catch block is used to manage the try block's unclear condition. A try block is always followed by a catch block, which deals with any exceptions thrown by the try block.
  finally keyword:- In Java, the finally block represents code that is to be executed whether or not an exception is caught
  throw keyword:- In Java, the throw keyword is used to throw an exception from a method or any block of code. We can either throw a checked or an unchecked exception. Throwing custom exceptions is the most common use of the throw keyword.
throws keyword:- The throws keyword is used to handle exceptions in the absence of a try/catch block. It specifies the exceptions that a method should throw in case an exception occurs.

21. Java Commands
- java –version:

22. Java Collections
The Collection interface (present in the java.util.Collection package) and the Map interface (present in the java.util.Map package) are the two basic root interfaces of Java collection classes.

- The following table lists the methods present in the collection interface:
     Method	Description
     add(Object)	It is a method for adding an object to a collection.
     addAll(Collection c)	This function populates this collection with all of the pieces from the provided collection.
     clear()	This method clears the collection of all its items.
     contains(Object o)	This method clears the collection of all its items.
     containsAll(Collection c)	If the collection contains all of the elements in the given collection, this method returns true.
     equals(Object o)	This method checks for equality between the specified object and this collection.
     hashCode()	It is a method that returns the hash code value for a collection.
     isEmpty()	It returns true if there are no elements in this collection.
     iterator()	It returns an iterator that traverses the elements of this collection.
     max()	The maximum value in the collection is returned by this method.
     size()	The number of elements in the collection is returned by the size() method.
     spliterator()	It is a function for creating a Spliterator over the elements in a collection.
     stream()	This method returns a sequential Stream whose source is this collection.
     toArray()	It returns an array that contains all of the elements in this collection.

- Interfaces that extends the Collections interface
  Iterable Interface: This is the collection framework’s root interface. The iterable interface is extended by the collection interface. As a result, all interfaces and classes implement this interface by default. This interface’s main purpose is to provide an iterator for the collections. As a result, this interface only has one abstract method, the iterator.
  Collection Interface: The Collection Interface extends the iterable interface and is implemented by all of the collection framework’s classes. This interface covers all of the basic methods that every collection has, such as adding data to the collection, removing data from the collection, clearing data, and so on. All of these methods are implemented in this interface since they are used by all classes, regardless of their implementation style. Furthermore, including these methods in this interface guarantees that the method names are consistent across all collections. In summary, we may conclude that this interface lays the groundwork for the implementation of collection classes.
  List Interface: The collection interface has a child interface called the list interface. This interface is dedicated to list data, in which we can store all of the objects in an ordered collection. This also allows for the presence of redundant data. Various classes, such as ArrayList, Vector, Stack, and others, implement this list interface. We can create a list object with any of these classes because they all implement the list.
  Java ArrayList: In Java, ArrayList allows us to create dynamic arrays. Though it may be slower than normal arrays, it might be useful in programs that require a lot of array manipulation. If the collection increases, the size of an ArrayList is automatically increased, and if the collection shrinks, the size of an ArrayList is automatically decreased. The Java ArrayList allows us to access the list at random. Primitive types, such as int, char, and so on, cannot be utilised with ArrayList. In such circumstances, we’ll require a wrapper class.
  Syntax -
  ArrayList<ObjectType>name=new ArrayList<ObjectType>(size_of_collection);
  Java LinkedList: The LinkedList class implements the LinkedList data structure, which is a linear data structure with items not stored in contiguous locations with each element being a separate object having a data and address part. Pointers and addresses are used to connect the elements. Every element is referred to as a node.
  Syntax -
  LinkedList<ObjectType> name = new LinkedList<ObjectType>(size_of_collection);
  Java Vector: In Java, a vector offers us dynamic arrays. Though it may be slower than normal arrays, it might be useful in programs that require a lot of array manipulation. In terms of implementation, this is similar to ArrayList. The main distinction between a vector and an ArrayList is that a vector is synchronised (i.e., thread-safe implying that it has some sort of locking mechanism before accessing shared data), but an ArrayList is not.
  Syntax -
  Vector<ObjectType> name = new Vector<ObjectType>(size_of_collection);
  Java Stack: The Stack data structure is modelled and implemented by the Stack class. The class is organised around the last-in-first-out philosophy. The class also includes three additional functions: empty, search, and peek, in addition to the fundamental push and pop operations. The subclass of Vector can also be used to refer to this class.
  Syntax -
  Stack<ObjectType> name = new Stack<ObjectType>(size_of_collection);
  Queue Interface: A queue interface, as the name implies, follows the FIFO (First In First Out) order of a real-world queue line. This interface is for storing all elements in which the order of the elements is important. When we try to book a ticket, for example, the tickets are sold on a first-come, first-served basis. As a result, the individual whose request is first in line receives the ticket. PriorityQueue, ArrayDeque, and other classes are available. Because all of these subclasses implement the queue, we can use any of them to create a queue object.
  Example -
  Queue<ObjectType> queue = new PriorityQueue<ObjectType> ();
  Deque Interface: This is just a little tweak to the queue data structure. Deque, also known as a double-ended queue, is a data structure in which elements can be added and removed from both ends. The queue interface is extended by this interface. ArrayDeque is the class that implements this interface. Because the ArrayDeque class implements the Deque interface, we can use it to create a deque object.
  Example -
  Deque<ObjectType> deque = new ArrayDeque<ObjectType> ();
  Set Interface: A set is an unordered collection of objects in which no duplicate values can be stored. This collection is utilised when we want to avoid duplication of things and only keep the unique ones. Various classes, such as HashSet, TreeSet, LinkedHashSet, and others, implement this set interface. We can create a set object with any of these classes because they all implement the set.
  Example -
  Set<ObjectType> set = new HashSet<ObjectType> ();
  SortedSet Interface: This interface resembles the set interface in appearance. The only difference is that this interface provides additional methods for maintaining element ordering. The sorted set interface is an extension of the set interface that is used to manage sorted data. TreeSet is the class that implements this interface. We can create a SortedSet object using this class because it implements the SortedSet interface.
  Example -
  SortedSet<ObjectType> set = new TreeSet<ObjectType> ();
  Map Interface: A map is a data structure that allows data to be mapped into key-value pairs. Because the same key cannot have multiple mappings, this interface does not support duplicate keys. If there is data and we want to do actions based on the key, a map is beneficial. Various classes, such as HashMap and TreeMap, implement this map interface. We can create a map object with any of these classes because they all implement the map


23. Java Generics
    Generics refer to types that have been parameterized. The goal is to make type (Integer, String, etc., as well as user-defined types) a parameter for methods, classes, and interfaces. Generics can be used to design classes that function with a variety of data types. A generic entity is a type that works on a parameterized type, such as a class, interface, or method.
    Type-safety: In generics, we can only hold one type of object.
    Typecasting isn’t necessary: When we use generics, we do not need to typecast the object when we access it.
    Checking at Compile Time: It is checked at compile time to ensure that an issue does not arise at runtime.

24. Java Multithreading
Multithreading is a Java feature that permits the execution of two or more portions of a program at the same time to maximise CPU efficiency. Each such portion of the program is referred to as a thread.
Threads are lightweight processes within processes. Multitasking is accomplished through the use of multiprocessing and multithreading. Because threads share a memory, we employ multithreading rather than multiprocessing. They conserve memory by not allocating separate memory space, and context-switching between threads takes less time than processing.

- Java Runnable Interface: In Java, java.lang.Runnable is an interface that a class must implement if its instances are to be executed by a thread.
- Java Thread Class: Thread programming is possible with Java’s Thread class. The Thread class contains constructors and methods for creating and operating on threads. Thread is a subclass of Object that implements the Runnable interface

Java Multithreading has the following advantages:
It does not impede the user because threads are independent and can conduct many operations at the same time.
It saves time by allowing you to conduct multiple procedures at once.
Because threads are self-contained, an exception in one thread has no impact on other threads.
How to implement multithreading in Java?

Multithreading can be performed in Java using two different mechanisms:
By Extending the Thread class.
By implementing the Runnable Interface.

- The following are the key differences between using the Runnable interface and the Thread class:
Because Java doesn’t support multiple inheritances, if we extend the Thread class, we won’t be able to extend any other classes. Our class, however, can still extend other base classes if we implement the Runnable interface.
We can obtain rudimentary thread functionality by extending the Thread class, which has several built-in methods like yield() and interrupt() that aren’t available in the Runnable interface.
When you use runnable, you’ll get an object that can be shared by numerous threads.

#### part 5



#### part 6



### JVM options java8
#### Available combinations of garbage collection algorithms in HotSpot JVM
#### 
#### 
#### 
#### 

### jvm concepts 
#### JVM performs following operation
- Loads code
  Verifies code
  Executes code
  Provides runtime environment
  JVM provides definitions for the:

Memory area
Class file format
Register set
Garbage-collected heap
Fatal error reporting etc.

#### Classloader
- Classloader is a subsystem of JVM which is used to load class files. Whenever we run the java program, it is loaded first by the classloader. There are three built-in classloaders in Java.

Bootstrap ClassLoader: This is the first classloader which is the super class of Extension classloader. It loads the rt.jar file which contains all class files of Java Standard Edition like java.lang package classes, java.net package classes, java.util package classes, java.io package classes, java.sql package classes etc.
Extension ClassLoader: This is the child classloader of Bootstrap and parent classloader of System classloader. It loades the jar files located inside $JAVA_HOME/jre/lib/ext directory.
System/Application ClassLoader: This is the child classloader of Extension classloader. It loads the classfiles from classpath. By default, classpath is set to current directory. You can change the classpath using "-cp" or "-classpath" switch. It is also known as Application classloader.

- class loader performs three basic activities in this strict order:
- Loading: finds and imports the binary data for a type
Linking: performs verification, preparation, and (optionally) resolution
Verification: ensures the correctness of the imported type
Preparation: allocates memory for class variables and initializing the memory to default values
Resolution: transforms symbolic references from the type into direct references.
Initialization: invokes Java code that initializes class variables to their proper starting values.

#### Class(Method) Area
- In the method area, all class level information like class name, immediate parent class name, methods and variables information etc. are stored, including static variables. There is only one method area per JVM, and it is a shared resource
- JVM Method Area stores class structures like metadata, the constant runtime pool, and the code for methods.
- Class(Method) Area stores per-class structures such as the runtime constant pool, field and method data, the code for methods.
#### Heap
- All the Objects, their related instance variables, and arrays are stored in the heap. This memory is common and shared across multiple threads.
- the runtime data area in which objects are allocated
#### Stack / Stack area
-  For every thread, JVM creates one run-time stack which is stored here. Every block of this stack is called activation record/stack frame which stores methods calls. All local variables of that method are stored in their corresponding frame. After a thread terminates, its run-time stack will be destroyed by JVM. It is not a shared resource
- Java Stack stores frames. It holds local variables and partial results, and plays a part in method invocation and return.
- Each thread has a private JVM stack, created at the same time as thread.
- A new frame is created each time a method is invoked. A frame is destroyed when its method invocation completes
#### Program Counter Register
- PC (program counter) register contains the address of the Java virtual machine instruction currently being executed
#### Native Method Stack
- It contains all the native methods used in the application.
#### Execution Engine
- A virtual processor
- Interpreter: Read bytecode stream then execute the instructions.
- Just-In-Time(JIT) compiler: It is used to improve the performance. JIT compiles parts of the byte code that have similar functionality at the same time, and hence reduces the amount of time needed for compilation. Here, the term "compiler" refers to a translator from the instruction set of a Java virtual machine (JVM) to the instruction set of a specific CPU.

#### Java Native Interface
- JNI) is a framework which provides an interface to communicate with another application written in another language like C, C++, Assembly etc. Java uses JNI framework to send output to the Console or interact with OS libraries

### Spring
#### Spring CS
##### part 1
- example of initialization during the start app properties:
spring.datasource.initialization-mode = h2
spring.datasource.platform = never
files:

schema.sql
schema-${platform}.sql

command line argument to specify external file with configuration
-Dspring.config.location=your/config/dir/application.properties
logging level, loglevel, spring boot logging
java -jar myapp.jar --debug
logging:
level:
ROOT: DEBUG
-Dlogging.level.root=debug
- logging to file, log to file
  -Dlogging.file 	
  -Dlogging.path
  -Dlogging.file=deployer.log -Dlogging.path=/dev/deployer/deployer.log -Dlogging.level.root=info
  spring boot another http port, change http port, change server port
  mvn spring-boot:run -Dserver.port=8090
  spring boot start application with specific profile
  java -Dspring.profiles.active={name of profile} -jar {path to jar/war with spring-boot inside}
  spring boot update DB schema, database update, hibernate update
  -Dspring.jpa.hibernate.ddl-auto=update

- bean post processor
  @Bean public BeanPostProcessor{return new BeanPostProcessor(){}}
  application event listener
  accessible events

  @EventListener
  public void applicationPidFileWriter(ApplicationPreparedEvent event){
  ApplicationPreparedEvent surrogateEvent = new ApplicationPreparedEvent(event.getSpringApplication(), new String[]{}, event.getApplicationContext());
  new ApplicationPidFileWriter().onApplicationEvent(surrogateEvent);
  }
  default name of annotated @Bean
  class name
  name of the declared method
  to specify the name of @Bean
  @Qualifier
  using bean by name
  @Resource(name="${<name of the value>}")
- add bean programmatically, add bean at runtime
  GenericApplicationContext context = ....;
  context.registerBean("int100", Integer.class, () -> new Integer(100));
  context.registerBean("int100Lazy", Integer.class, () -> new Integer(100), (bd) -> bd.setLazyInit(true));
  hierarchy
  if @Component extends another @Component, parent won't visible for Spring context

refresh context for testing
@DirtiesContext
for starting context
@SpringBootTest instead of @BootstrapWith
spring boot actuator, spring boot list of all elements
dependency

      <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
      </dependency>
endpoints

http://localhost:8808/actuator

- health check of Spring Boot application
  <url:port>/<application>/health
  Spring Boot h2, h2 console, Spring Boot h2, conditional bean, register bean if condition is matches
  import org.h2.server.web.WebServlet;

  @Bean
  @Conditional(OpmGuiConfiguration.H2Contidion.class)
  ServletRegistrationBean h2servletRegistration(){
  ServletRegistrationBean registrationBean = new ServletRegistrationBean( new WebServlet());
  registrationBean.addUrlMappings("/h2-console/*");
  return registrationBean;
  }

  public static class H2Contidion implements Condition{
  @Override
  public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {
  return Arrays.asList(conditionContext.getEnvironment().getActiveProfiles()).contains("h2");
  }
  }
<!-- https://mvnrepository.com/artifact/com.h2database/h2 -->
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <version>1.4.197</version>
    <scope>test</scope>
</dependency>

- conditional bean, bean with specific methods
  @Bean(initMethod = "start", destroyMethod = "stop")
  @ConditionalOnMissingBean(InstanceRepository.class)
  junit test abstract file with custom copmonent scanning
  @RunWith(SpringJUnit4ClassRunner.class)
  @ContextConfiguration(loader = AnnotationConfigContextLoader.class, classes={SpringStepTest.TestConfiguration.class})
  public abstract class SpringStepTest {

  @Autowired
  ApplicationContext context;

  @Configurable
  @ComponentScan(basePackages = {"com.cd.deployer.step"})
  public static class TestConfiguration {}
  }
  not to start web application
  new SpringApplicationBuilder(CommandExecutorApplication.class).web(WebApplicationType.NONE).run(args);
- set variable from expression
  @Autowired
  JSONReader jsonReader;

  @Value("${steps}")
  String pathToSteps;
  @Value("${failSteps}")
  String pathToFailSteps;

  // Value("#{JSONReader.parse(JSONReader.readFile('${steps}'))}")
  List<StepWithParameters> steps;

  // Value("#{JSONReader.parse(JSONReader.readFile('${failSteps}'))}")
  List<StepWithParameters> failSteps;

  @PostConstruct
  public void afterBuild(){
  this.steps = jsonReader.parse(jsonReader.readFile(Objects.isNull(pathToSteps)?System.getProperty("steps"):pathToSteps));
  this.failSteps = jsonReader.parse(jsonReader.readFile(Objects.isNull(pathToFailSteps)?System.getProperty("failSteps"):pathToFailSteps));
  }



##### part 2
- Spring boot issues
  error during start standalone web application
  Unable to start web server; nested exception is org.springframework.context.ApplicationContextException:
  Unable to start ServletWebServerApplicationContext due to missing ServletWebServerFactory bean.
  just update pom.xml

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
multipart upload
"status":400,"error":"Bad Request","message":"Required request part 'file' is not present","path":"/"
application.properties

spring.servlet.multipart.max-file-size=128MB
spring.servlet.multipart.max-request-size=128MB
spring.servlet.multipart.enabled=true
No serialization found for class
HttpEntity<String> request = new HttpEntity<>(new ObjectMapper().writeValueAsString(registration), headers);
or
ObjectMapper mapper = new ObjectMapper();
mapper.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY);
HttpEntity<String> request = new HttpEntity<>(mapper.writeValueAsString(registration), headers);

- Monitoring
  Crash
  crash.sh {Process ID}
  <dependency>
  <groupId>org.crashub</groupId>
  <artifactId>crash.embed.spring</artifactId>
  <version>1.3.2</version>
  </dependency>
  <dependency>
  <groupId>org.crashub</groupId>
  <artifactId>crash.connectors.ssh</artifactId>
  <version>1.3.2</version>
  </dependency>
  <dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-remote-shell</artifactId>
  </dependency>

- spring-shell
  maven dependency
  <dependency>
  <groupId>org.springframework.shell</groupId>
  <artifactId>spring-shell-starter</artifactId>
  <version>2.0.0.RELEASE</version>
  </dependency>
  <dependency>
  <groupId>org.springframework.shell</groupId>
  <artifactId>spring-shell</artifactId>
  <version>2.0.0.RELEASE</version> 
  </dependency>
  At leas one ShellComponent MUST present !!!

import org.springframework.shell.standard.ShellComponent;
import org.springframework.shell.standard.ShellMethod;

@ShellComponent
public class HelloClass {
@ShellMethod("hello")
public String hello(){
return "jello";
}
}

skip commands
public static void main(String[] args) throws Exception {
String[] disabledCommands = {"--spring.shell.command.help.enabled=false"};
String[] fullArgs = StringUtils.concatenateStringArrays(args, disabledCommands);
SpringApplication.run(MyApp.class, fullArgs);
}


##### part 3
- skip command exit, skip close sprintshell
  String[] disabledCommands = {"--spring.shell.command.quit.enabled=false"};
  disable interactive collaboration, disable spring shell
  spring.shell.interactive.enabled=false
- spring boot maven plugin for building fat jar, uber jar, jar with all dependencies
  <plugins>
  <plugin>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-maven-plugin</artifactId>
  </plugin>
  </plugins>

- spring boot admin
  source code doc

maven dependency
<parent>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-parent</artifactId>
<version>2.0.2.RELEASE</version>
<relativePath/>
</parent>

  <dependencies>
    <dependency>
        <groupId>de.codecentric</groupId>
        <artifactId>spring-boot-admin-starter-server</artifactId>
        <version>2.0.0</version>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
  </dependencies>

- register client on server side
  @Bean
  CommandLineRunner registerClient(InstanceRegistry registry){
  return new CommandLineRunner() {
  @Override
  public void run(String... args) throws Exception {
  Registration build = Registration.builder()
  .name("sit")
  // .managementUrl("http://v337:9001/env")
  .healthUrl(    "http://v337:9001/health")
  .serviceUrl(   "http://v337:9001")
  // .source(       "http://v337:9001")
  .build();

                Mono<InstanceId> response = registry.register(build);
                System.out.println(response.block());
            }
        };
  }
  curl request to register new instance
  curl -X POST -H "content-type:application/json;charset=UTF-8" -d "@register-host.json" http://localhost:8080/instances
  {
  "name":"new host",
  "healthUrl": "http://v337:9001/health",
  "serviceUrl": "http://v337:9001",
  "metadata": {
  "version":"1"
  "controlUrl":"my-own-manager:8080"
  }
  }


##### part 4


### tomcat
####  Tomcat installation
- wget from https://tomcat.apache.org/download-80.cgi
  http port:
  file:conf/server.xml XML:Connector@port

manager application
file:conf/tomcat-users.xml should be able to be readable
file:conf/tomcat-users.xml ( manager-gui, manager-script )
#### Tomcat debug
  update file: setenv.sh

for linux:
export "JAVA_OPTS=$JAVA_OPTS -Dcatalina.log.level=INFO -Xmx1024m -Duser.timezone=UTC -Dspring.config.location=apache-tomcat-8.0.41-brandserver/conf/application-cherkavi.yml"
export CATALINA_OPTS="-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=9009 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false"
for windows:
set "JAVA_OPTS=%JAVA_OPTS% -Dcatalina.log.level=INFO -Xmx1024m -Duser.timezone=UTC -Dspring.config.location=C:\soft\tomcat\apache-tomcat-8.0.41-brandserver\conf\brand-application-cherkavi.yml"
set "CATALINA_OPTS=-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=9009 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false"






#### OPERATIONS AND SYSTEM SECURITY
- Patch and Vulnerability Management
- Least Privilege for the Tomcat Service
- Restrict Access to Tomcat Folder
  This is especially valid
  for the directories ${tomcat_home}/conf/ and ${tomcat_home}/webapps
- ADMINISTRATIVE INTERFACES
- 'Minimal Principle' Authorization Concept
  Depending on the given tasks, only rights for respective roles must be assigned. The following
  roles are available and must be assigned with minimal privileges in mind:
  ¬ manager-gui: Access to the web interface
  ¬ manager-status: Access to the “Server Status”-page only
  ¬ manager-script: Access to the script-oriented plain-text interface and “Server
  Status” page
  ¬ manager-jmx: Access to the JMX proxy interface and the “Server Status” page
- Secure Authentication
  Edit the file CATALINA_HOME/conf/server.xml and add the lockout realm with the
  following option:

<Realm className="org.apache.catalina.realm.LockOutRealm"
failureCount="5" lockOutTime="30">
</Realm>
- Open the file CATALINA_HOME/conf/server.xml. Search for the MemoryRealm and
  disable it. The JDBCRealm must also be disabled. Use the DataSourceRealm instead.
  When using a large-scale installation, do not use the UserDatabaseRealm and disable it
  as well 
- This can be done by editing the file in the CATALINA_HOME/conf/web.xml and setting the
  following configuration option:
  <session-config>
  <session-timeout>20</session-timeout>
  </session-config>
- HttpOnly can be activated with the following configuration option that must be set in
  CATALINA_BASE/conf/context.xml to be enabled globally on all applications:
  <Context useHttpOnly='true' .../>
- Cross Site Request Forgery protection in Tomcat must be enabled in order to protect
  applications. Tomcat 7 provides a basic CSRF protection. A filter can be configured in
  CATALINA_BASE/conf/web.xml globally. The filter can be overwritten by each application
  using the file WEB-INF/web.xml.
  The following configuration options must be set:
  <filter-mapping>
  <filter-name>CSRFPreventionFilter</filter-name>
  <url-pattern>/*</url-pattern>
  </filter-mapping>
- Restrict Listening Interfaces
  Edit the file CATALINA_HOME/conf/server.xml. Review every connector and specify the
  correct IP address:
  <Connector port="TCP_PORT" address="LISTEN_IP_ADDRESS"…
- Restrict Allowed Network Connections
  Open the file CATALINA_HOME/conf/server.xml and review every Connector
  configuration for the correct/desired port assignment. Remove unused ports/connectors.
- Encrypt Network Connections
  To enable SSL support, the following line can be used (the exact configuration options depend
  on the given platform and requirements) and must be placed in the
  CATALINA_HOME/conf/server.xml:
  <Connector protocol="org.apache.coyote.http11.Http11Protocol"
  port="8443" scheme="https" secure="true" SSLEnabled="true"
  sslProtocol="TLS" keystoreFile="path to keystore file"
  keystorePass="keystore password"/>
  Restriction of available SSL Ciphers by adding the ciphers attribute to the SSL Connector with
  the following cipher suites:
  <Connector ciphers="SSL_RSA_WITH_RC4_128_SHA,
  TLS_RSA_WITH_AES_128_CBC_SHA, TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
  TLS_DHE_DSS_WITH_AES_128_CBC_SHA, SSL_RSA_WITH_3DES_EDE_CBC_SHA,
  SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA,
  SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA" …
  The enforcement of SSL only communication must be done in one of the following 2 ways:
  To force the usage of HTTPS for all Web Applications hosted on the Tomcat, each securityconstraint tag within each CATALINA_HOME/webapps/$WEBAPP/WEB-INF/web.xml must
include the following lines right before the closing </security-constraint> tag:
  <user-data-constraint>
  <transport-guarantee>CONFIDENTIAL</transport-guarantee>
  <user-data-constraint>
- Secure Shutdown Port
  Edit the file CATALINA_HOME/conf/server.xml and set the shutdown passphrase:
  <Server port="8005"
  shutdown="NonDeterministicWordSoShutdownPWisNotEasyToGuess">
  If this functionality is not needed, it must be deactivated with the following option
  <Server port="-1" shutdown="SHUTDOWN">
  The local management scripts allow a shutdown of the server even if the shutdown port is
  disabled.
- Remove all default web applications from ${tomcat_home}/webapps. Standard
  applications which must be removed are ROOT, docs, examples, host-manager, and
  manager.
- Automatic deployment is controlled by the autoDeploy and deployOnStartup attributes. If both
  are false, only Contexts defined in server.xml will be deployed and any changes will require
  a Tomcat restart. To disable automatic deployment change the following lines in the
  $CATALINA_HOME/conf/server.xml file:
  autoDeploy=”false”
  deployOnStartup=”false”


#### DEFAULT SETTINGS
- The following items list default settings which must not be changed as these are considered secure by default:
 The value of allowTrace for each Connector within the server.xml is either not present or set to false.
 In all context.xml files set the privileged attribute to false unless it is required like for the manager application:
¬ <Context ... privileged=”false” />
 Ensure that the crossContext value is either not present or set to false.
Allowing crossContext creates the possibility for a malicious application to make requests to a restricted
application.
<Context ... crossContext=”false” />
 Ensure that the allowLinking value is either not present or set to false.
Allowing symbolic links creates the possibility for directory traversal and source code disclosure vulnerabilities.
<Context ... allowLinking=”false” />
 Do not allow write access for default servlet.
¬ The DefaultServlet is configured with read-only set to true in the Wweb.xml file. Changing this to false
allow clients to delete or modify static resources on the server and to upload new resources. This should
not normally be changed without requiring authentication.
 Do not enable listing
¬ The DefaultServlet is configured with listings set to false. This is not only because allowing directory
listings is considered unsafe but because generating listings of directories with thousands of files can
consume significant CPU resources, leading to a DoOS attack.
 When the RECYCLE_FACADES option is set to true, Tomcat will recycle the session facade between requests. This
will lead to information leakage between requests. By default, this parameter is not set. Ensure that the startup
script in use does not contain the following line:
¬ -Dorg.apache.catalina.connector.RECYCLE_FACADES=false
 Being able to specify different path delimiters on Tomcat gives an attacker the possibility to access applications that
were previously blocked by a proxy like mod_proxy. Per default, this parameter is not set.
¬ Ensure that the startup script in use does not contain the following line:
¬ -Dorg.apache.catalina.connector. CoyoteAdapter.ALLOW_BACKSLASH=false
¬ -Dorg.apache.tomcat.util.buf. UDecoder.ALLOW_ENCODED_SLASH=false
 Being able to specify custom header status messages enables an attacker to inject headers. This allows a potential
attack vector for Cross-Site Scripting attacks. Per default, this parameter is not set.
¬ Ensure that the startup script in use does not contain the following line:
¬ -Dorg.apache.coyote.USE_CUSTOM_STATUS_MSG_IN_HEADER=false
#### Tomcat - Cheatsheet
- How can we start Tomcat with parameter that enable remote debugging?

catalina.sh jpda start
How can we start Tomcat using another server.xml file?

catalina.sh -config /path/to/server.xml
How can we pass the -D additional parameter while starting tomcat?

We can set an environment variable (before starting tomcat):

export CATALINA_OPTS="-Dapp.username -Dapp.username"
set CATALINA_OPTS="-Dapp.username -Dapp.username"
export JAVA_OPTS="-Dapp.username -Dapp.username" // Linux
set JAVA_OPTS="-Dapp.username -Dapp.username" // Windows
We should use CATALINA_OPTS instead of JAVA_OPTS. The CATALINA_OPTS is only used by Tomcat.

How can we make a webapp hot deployable?

Add the following line to the server.xml:

<Context path="/yourContext" reloadable="true" docBase="rootFolderOfYourApp" />

- How can we enable admin or manager?

By default, Tomcat does not enable admin or manager access. To enable it, you have to edit the “%TOMCAT_FOLDER%/conf/tomcat-users.xml”.

<?xml version='1.0' encoding='utf-8'?>
<tomcat-users>
<!--
  <role rolename="tomcat"/>
  <role rolename="role1"/>
  <user username="tomcat" password="tomcat" roles="tomcat"/>
  <user username="both" password="tomcat" roles="tomcat,role1"/>
  <user username="role1" password="tomcat" roles="role1"/>
-->
  <role rolename="manager"></role>
  <role rolename="admin"/>
  <user username="admin" password="admin" roles="admin,manager"/>
</tomcat-users>
How can we configure Tomcat session timeout duration?

Locate the conf/web.xml file. Look for

<session-config>
    <session-timeout>30</session-timeout>
</session-config>
The timeout value is specified in minutes. Restart Tomcat after modifying the file, so the changes can take effect.

- How can we change the name of the session cookie?

By default, Java web applications use the cookie name JSESSIONID. If you were to integrate two separate Java applications using HTML frames, you may have a risk that your applications may get confused because it is seeing the session ID from the other application, and this session ID does not exists. If your applications are being served by different containers or servers, you may need to configure your web container to use a different name for your session cookie for each application.

The related system properties are:

org.apache.catalina.SESSION_COOKIE_NAME (for cookie name)
org.apache.catalina.SESSION_PARAMETER_NAME (for parameter name)
System property can be passed using standard methodology; use “-D” parameter of Java command similar to following.

java -D<key>=<value>
Modify catalina.sh to pass system properties:

JAVA_OPTS="$JAVA_OPTS
-Dorg.apache.catalina.SESSION_COOKIE_NAME=MYJSESSIONID
-Dorg.apache.catalina.SESSION_PARAMETER_NAME=myjsessionid"
Tomcat 7 moves this from org.apache.catalina.SESSION_COOKIE_NAME to an attribute on the main context. See http://tomcat.apache.org/migration-7.html#Session_manager_configuration

<Context path="/yourApp" sessionCookieName="custom_session_id"></Context>

- What are some of the strategies that you can use to improve your site performance?

For static content, consider using a CDN, or configure your infrastructure so that static content is routed (using the capability of your load balancer) to dedicated servers that are specifically configured and optimized to serve static contents.
Use benchmark tools to obtain a clear, comprehensive picture of your site's current performance.
Study, refactor, and benchmark your code. Before making any improvements, it is essential that you establish an accurate benchmark of your site's current performance, so that any changes can be measured in a useful, quantifiable manner. Tools that can be used to benchmark your code: Apache JMeter, ab (a benchmark tool provided by Apache).
Identify the bottlenecks in your architectures.
Consider adding more servers.
Consider adding more memory if your servers seems to be memory-bounded.
Consider using faster CPU if your servers seems to be CPU-bounded.
Consider changing your hard disk configuration such as adding a better hard disk controller, a better hard disk, using RAID or SCSI if your server seems to be IO-bounded. See http://www.staff.uni-mainz.de/neuffer/scsi/what_is_raid.html, http://computer.howstuffworks.com/scsi1.htm
Upgrade to using the latest stable JVM release.
Tune your JVM
Consider experimenting with your JVM threading configuration. If your JVM supports both green and native threads, you should try both models. If you are running IO-bound applications, native thread should offer improved performance. However, green thread will decrease the load placed on your machine. Native thread is usually a good choice.
Certains JVM processes, such as garbage collection and memory re-allocation, can be a drain on your server. You can reduce the frequency with which these processes occur by using the -Xmx and -Xms switches to control how JVM handles its heap memory.
JVM garbage collection can use up valuable CPU power. To reduce the frequency with which JVM invokes garbage collections, use the -Xmx switch to start the JVM with a higher maximum heap memory. To maximize the effectiveness of this technique, use the -Xms switch to ensure that the JVM's initial heap memory size is equal to the maximum allocated memory. This will keep Tomcat JVM from having to reallocate and resize its heap memory. If your application can handle the possibility of lower total garbage collection throughput, you should try enabling incremental collection with -Xincgc
If you need more information on the way your current configuration is handling your collection load, use the -verbose:gc to capture performance data.
Update to the latest version of Tomcat
How will configuring maxThreads Connector setting improve your site performance?

Basing your maxThreads Connector thread pool settings on an accurate estimation of your web request load is essential for getting the most out of Tomcat. Values that are too small can leave you without enough threads to handle all your requests and prevent Tomcat from effectively utilizing your server hardware. Values that are too high can significantly increase Tomcat's startup time, which is critical issue at peak traffic interval. Experiment with different values to determine the best middle ground.

How will using compression help or impact performance?

By default, compression is set to off, but some application performs better when it is switched to on. Try changing this settings and see what work best for your application. Consider using the compressableMimeTypes setting to specify what types of data you want compressed.

If we have a choice between using HTTP versus HTTPS, which one should we use?

In general, using HTTP instead of HTTPS will result in much better performance. However, HTTP may not be the right choice for your site.

What is the sequence that Tomcat uses to load Java library files during start-up?

The JVM bootstrap loader loads the core Java libraries. Incidentally, this is the one place where environment variables do matter, as the JVM locates the core libraries using the JAVA_HOME variable.
Startup.sh, calling Catalina.sh with the "start" parameter, overwrites the system classpath and loads bootstrap.jar and tomcat-juli.jar. These resources are only visible to Tomcat.
Class loaders are created for each deployed Context, which load all classes and JAR files contained in each web application's WEB-INF/classes and WEB-INF/lib, respectively and in that order. These resources are only visible to the web application that loads them.
The Common class loader loads all classes and JAR files contained in $CATALINA_HOME/lib. These resources are visible to all applications and to Tomcat.
- How can we configure Tomcat to use an external class loader?

To make Tomcat aware of an external repository, declare the file in catalina.properties under the shared loader, using the correct syntax. Syntax will vary based on the type of file or repository you are attempting to configure:

To add a folder as a class repository, use the format "path/to/foldername"
To add all JARs in a folder as class repositories, use the format: "path/to/foldername/*.jar"
To add a single JAR file as a class repository, use the following format: "file://path/to/foldername/jarname.jar"
To call environment variables, use the ${} format, i.e. ${VARIABLE_NAME}
To declare multiple resources, separate each entry with a comma.
All paths may be relative to CATALINA_BASE or CATALINA_HOME, or absolute.

If you have multiple web applications, and they all depend on a certain JAR file, what should you do?

It is best not to include additional libraries other than common 3rd party libraries such as JDBC drivers in $CATALINA_HOME/lib, even though this will work in some situations. Instead, recreate the "/shared/lib" and "/shared/classes" directories used in Tomcat 5.x, and configure them in catalina.properties by editing the shared.loader attribute:

"shared/classes,shared/lib/*.jar"
If you are embedding Tomcat inside another container, and you are having classpath issue, what should you do?

Java class loading is "lazy", which means that the first classloader that requests a certain class owns the class for the remainder of its lifecycle. If the System classloader, whose classes are not visible to the web application, loads the framework class first, the JVM will prevent additional instances of the class from being created, causing the classpath errors.

The way to get around this problem is to add a custom bootstrap classloader to your application. Configure this classloader to load the appropriate libraries on behalf of your web application, and then trigger the start-up of the rest of the application as normal. This will resolve all classloader conflicts in favor of your application.



#### 
#### 
#### 
#### 
#### 

### references
### r
- https://www.interviewbit.com/java-cheat-sheet/
- https://www.javatpoint.com/jvm-java-virtual-machine
- https://en.wikipedia.org/wiki/Java_virtual_machine#:~:text=A%20Java%20virtual%20machine%20(JVM)%20is%20a%20virtual%20machine%20that,required%20in%20a%20JVM%20implementation.
- https://dzone.com/articles/jvm-architecture-explained
- https://github.com/cherkavi/cheat-sheet/blob/master/tomcat.md
- https://github.com/cherkavi/cheat-sheet/blob/master/spring.md
- http://khaidoan.wikidot.com/tomcat-cheatsheet