# dos
## java
### java.lang.
#### part 1
- 1. Java Terminology
     Let us quickly go through some of the most important terms used in the Java programming language.
- JVM: The JVM stands for Java Virtual Machine. A program’s execution is divided into three stages. A Java program is written, compiled and then run.
  As we can see in the above image, first the JVM language classes are processed by the class loader subsystem which is responsible for 
- loading, linking and initialization of the java classes. After being processed by the class loader, the generated files are stored in the 
- JVM Memory which consists of method area, heap, JVM language stacks, PC registers and native method stacks. The execution engine accesses the files from this JVM memory and makes use of the Native Method Interface and Native Method Libraries.

A Java programmer creates a program.
The JAVAC compiler, which is a primary Java compiler provided in the Java development kit (JDK), is used to compile the code. It accepts a Java application as input and outputs bytecode.
JVM runs the bytecode generated by the compiler during the program’s Running phase.
The Java Virtual Machine’s job is to run the bytecode generated by the compiler. Although each operating system has its own JVM, the output they provide after bytecode execution is consistent across all of them. Java is known as a platform-independent language for this reason.

Bytecode: Bytecode is a type of intermediate code generated by the compiler after source code has been compiled (JAVA Program). Java is a platform-independent language thanks to this intermediate code.

- JRE: The Java Runtime Environment (JRE) is included with the JDK. The JRE installation on our computers allows us to run the Java program, but we cannot compile it. A browser, JVM, applet support, and plugins are all included in JRE. JRE is required for a computer to run a Java program.
JVM together with the Java Class Libraries makes up the JRE.

- Java Development Kit (JDK): When we learn about bytecode and JVM, we use the name JDK. As the name implies, it is a complete Java development kit that includes everything from the compiler to the Java Runtime Environment (JRE), debuggers, and documentation. In order to design, compile, and run the java application, we must first install JDK on our computer.
 JRE when combined with Development Tools makes up JDK.

- Garbage Collection: Garbage collection is the technique through which Java programs maintain their memory automatically. Java programs are compiled into bytecode that may be executed by a Java Virtual Machine, or JVM. Objects are produced on the heap, which is a part of memory devoted to the Java application, while it runs on the JVM. Some objects will become obsolete over time. To free up memory, the garbage collector detects these useless objects and deletes them.

- finalize method: It’s a method that the Garbage Collector calls shortly before deleting or destroying an object that’s suitable for Garbage Collection in order to do cleanup. Clean-up activity entails de-allocating or closing the resources associated with that object, such as Database Connections and Network Connections. It’s important to remember that it’s not a reserved keyword. Garbage Collector destroys the object as soon as the finalise method completes. The finalise method is found in the Object class and has the following syntax: protected void finalize throws Throwable{}

Since the finalize function is contained in the Object class and Object is the superclass of all Java classes, the finalize method is available to all Java classes. As a result, the garbage collector may invoke the finalise function on any java object. We must override the finalize method present in the Object class to specify our own clean-up activities since the finalize function in the Object class has an empty implementation

2. Java Basics
- object - An object is an entity with state and behaviour, such as a chair, a bike, a marker, a pen, a table, a car, and so on. It could be either physical or logical (tangible or intangible). The financial system is an example of an intangible object
- three characteristics of an object
State: The data (value) of an object is represented by its state.
Behaviour: The functionality of an object, such as deposit, withdrawal, and so on, is represented by the term behaviour.
Identity: A unique ID is often used to represent an object’s identification. The value of the ID is hidden from the outside user. The JVM uses it internally to uniquely identify each object.
- class - A class is a collection of objects with similar attributes. It’s a blueprint or template from which objects are made. It’s a logical thing. It can’t be physical. In Java, a class definition can have the following elements:
Modifiers: A class can be private or public, or it can also have a default access level
class keyword: To construct a class, we use the class keyword.
class name: The name of the class should usually start with a capital letter.
Superclass (optional): If the class has any superclass, we use the extends keyword and we mention the name of the superclass after the class name.
Interface (optional): If the class implements an interface, we use the implements keyword followed by the name of the interface after the class name.
- Constructors: A constructor in Java is a block of code that is comparable to a method. When a new instance of the class is created, the constructor is invoked. It is only when the constructor is invoked that memory for the object is allocated.
- 
  ```
      keyword - Reserved words are another name for Java keywords. Keywords are specific terms that have special meanings. Because these are Java’s predefined words, they can’t be used as variable, object, or class names. Following is the list of keywords used in Java:-
    Keyword	Use Case
    boolean	The boolean keyword in Java is used to declare a variable to be of the boolean type. It can only store True and False values.
    byte	The byte keyword in Java is used to create a variable that can handle 8-bit data values.
    break	The break keyword in Java is used to end a loop or switch statement. It interrupts the program’s current flow when certain circumstances are met.
    abstract	The abstract keyword in Java is used to declare an abstract class.
    case	The case keyword in Java is used with switch statements to mark text blocks.
    try	The try keyword in Java is used to begin a block of code that will be checked for errors. Either a catch or a finally block must come after the try block.
    short	The Java short keyword is used to declare a variable with a 16-bit integer capacity.
    void	The void keyword in Java is used to indicate that a method has no return value.
    static	The static keyword is used to denote a class method or a class variable in Java.
    synchronized	In multithreaded programming, the synchronized keyword is used to designate the critical sections or functions.
    super	The super keyword in Java is a reference variable that refers to parent class objects. It can be used to call the method of the immediate parent class.
    volatile	The volatile keyword in Java is used to signal that a variable might change asynchronously.
    while	The while keyword in Java is used to initiate a while loop. This loop repeats a section of the program many times. The while loop is recommended if the number of iterations is not predetermined.
    catch	The catch keyword in Java is used to capture exceptions thrown by try statements. It can only be used after the try block.
    char	Declare a variable that can hold unsigned 16-bit Unicode characters with the char keyword.
    class	To declare a class in Java, use the class keyword.
    continue	The continue keyword in Java is used to keep the loop going by continuing the program’s current flow while skipping the remaining code at the specified circumstance.
    default	The default keyword in Java can be used to define a default block of code in a switch statement. It can also be used as a default access modifier.
    do	The do keyword in Java is used to declare a loop in the control statement. It can repeat a section of the program multiple times.
    double	The double keyword in Java is used to create a variable that can hold a 64-bit floating-point number.
    else	In an, if statement, the else keyword in Java is used to represent alternate branches.
    enum	The enum keyword in Java is used to specify a set of fixed constants.
    extends	The extends keyword in Java is used to show that a class is inherited from another class or interface.
    final	
    The final keyword in Java can be used with variables, methods and classes. 
    When used with a variable, the value of the variable becomes constant. Any modifications in the variable’s value at a later stage leads to a compilation error.
    When used with a method, the method cannot be overridden in the classes that extend the given class.
    When used with a class, the class becomes noninheritable.
    finally	In a try-catch structure, the finally keyword denotes a code block. Whether or not an exception is handled, this block is always run.
    float	The float keyword in Java is used to create a variable that can carry a 32-bit floating-point value.
    for	The for keyword in Java is used to begin a for loop. When a condition is met, it is used to repeatedly execute a set of instructions/functions.
    if	The if keyword in Java is used to test a condition. If the condition is true, the if block is executed.
    implements	The keyword implements is used in Java to implement an interface.
    import	The import keyword in Java makes classes and interfaces available to the current source code.
    throw	The throw keyword in Java is used to throw an exception explicitly. Throwing custom exceptions is the most common use of the throw keyword.
    this	The this keyword is used to refer to the current object in the method or the constructor of the class.
    throws	The throws keyword in Java is used to declare an exception. throws can be used to propagate checked exceptions.
    instanceof	The instanceof keyword in Java is used to determine whether an object is an instance of a given class or implements an interface.
    int	The int keyword in Java is used to declare a variable that can hold a signed 32-bit integer.
    interface	The interface keyword in Java is used to declare an interface.
    long	The long keyword in Java is used to specify a variable that may store a 64-bit integer.
    native	The Java native keyword indicates that a method is implemented using JNI (Java Native Interface) in native code.
    new	The new keyword in Java is used to create new objects.
    null	The null keyword in Java is used to indicate that a reference refers to nothing.
    private	The private keyword in Java is an access modifier. It’s used to say that a method or variable can only be accessible in the class where it’s declared.
    protected	The protected keyword in Java is an access modifier. It can be accessed both within and outside the package, but only through inheritance.
    public	The public keyword in Java is an access modifier. It’s a term meaning anything can be found anyplace. Among all the modifiers, it has the broadest application.
    return	When a method’s execution is complete, the Java return keyword is used to exit the method.
  ```
3. Variables in Java
- Types of variables:
Local variable - A local variable is a variable defined within a block, method, or constructor. These variables have a scope that is limited to the block in which they are defined. i.e., these variables are only accessible within that block.
Instance variable - Variables that are declared inside a class without the ‘static’ keyword are referred to as instance variables. Instance variables are replicated for every object of the class being created.
Static variable - Variables that are declared inside a class with the ‘static’ keyword are referred to as static variables. Static variables are shared by all the objects of the class and are not replicated. Static variables are created at the start of program execution and automatically destroyed when the program is finished. It is not necessary to initialise a static variable. It has a value of 0 by default.

4. Datatypes in Java
- Primitive Data Types
- 
  ```
      Data Type	Default Size	Description
    boolean	1 bit	Only two potential values are stored in the Boolean data type: true and false. Simple flags that track true/false circumstances are stored in this data type.
    char	2 byte	A single 16-bit Unicode character is represented by the char data type. It has a value range of ‘\u0000’ (or 0) to ‘\uffff’ (or 65,535 inclusive).
    byte	1 byte	It’s an 8-bit two-s complement signed integer. It has a value range of -128 to 127. (inclusive). It has a value of 0 by default. The byte data type is used to preserve memory in huge arrays where space is at a premium. Because a byte is four times smaller than an integer, it saves space.
    short	2 bytes	A 16-bit signed two’s complement integer is the short data type. It has a value range of -32,768 to 32,767. (inclusive). It has a value of 0 by default.
    int	4 bytes	A 32-bit signed two’s complement integer is represented by the int data type. Its range of values is (-2^31) to (2^31 -1)(inclusive).
    long	8 bytes	A 64-bit two’s complement integer is the long data type. It has a value range of (-2^63) to (2^63 -1)(inclusive).
    float	4 bytes	The float data type is a 32-bit IEEE 754 floating-point with single precision. If you need to preserve memory in big arrays of floating point integers, use a float (rather than a double).
    double	8 bytes	A double data type is a 64-bit IEEE 754 floating-point with double precision. Like float, the double data type is commonly used for decimal values. For precise values, such as currency, the double data type should never be utilised. 0.0d is the default value.
  ```

#### part 2
5. Java Keywords
- a) Understanding the this keyword in Java:
this: to refer to the current instance variable of the class
this: to call the method of the current class
this() is used to call the constructor of the current class
this: to use as a parameter in a method
this keyword can be used to get the current instance of a class
- b) final keyword in Java:
Final Variables:
Final Classes:
Final Methods:
- c) static keyword in Java:
Static Blocks:
Static Variables:
Static Methods:
Static Classes:
- d) super keyword in Java: 
Using super with variables:
Using super with methods:

6. Java Comments
- Single line comments:  // 
- Multiline comments:


#### part 3


#### part 4


#### part 5



#### part 6



### JVM options java8
#### Available combinations of garbage collection algorithms in HotSpot JVM
#### 
#### 
#### 
#### 

### jvm concepts 
#### JVM performs following operation
- Loads code
  Verifies code
  Executes code
  Provides runtime environment
  JVM provides definitions for the:

Memory area
Class file format
Register set
Garbage-collected heap
Fatal error reporting etc.

#### Classloader
- Classloader is a subsystem of JVM which is used to load class files. Whenever we run the java program, it is loaded first by the classloader. There are three built-in classloaders in Java.

Bootstrap ClassLoader: This is the first classloader which is the super class of Extension classloader. It loads the rt.jar file which contains all class files of Java Standard Edition like java.lang package classes, java.net package classes, java.util package classes, java.io package classes, java.sql package classes etc.
Extension ClassLoader: This is the child classloader of Bootstrap and parent classloader of System classloader. It loades the jar files located inside $JAVA_HOME/jre/lib/ext directory.
System/Application ClassLoader: This is the child classloader of Extension classloader. It loads the classfiles from classpath. By default, classpath is set to current directory. You can change the classpath using "-cp" or "-classpath" switch. It is also known as Application classloader.

- class loader performs three basic activities in this strict order:
- Loading: finds and imports the binary data for a type
Linking: performs verification, preparation, and (optionally) resolution
Verification: ensures the correctness of the imported type
Preparation: allocates memory for class variables and initializing the memory to default values
Resolution: transforms symbolic references from the type into direct references.
Initialization: invokes Java code that initializes class variables to their proper starting values.

#### Class(Method) Area
- In the method area, all class level information like class name, immediate parent class name, methods and variables information etc. are stored, including static variables. There is only one method area per JVM, and it is a shared resource
- JVM Method Area stores class structures like metadata, the constant runtime pool, and the code for methods.
- Class(Method) Area stores per-class structures such as the runtime constant pool, field and method data, the code for methods.
#### Heap
- All the Objects, their related instance variables, and arrays are stored in the heap. This memory is common and shared across multiple threads.
- the runtime data area in which objects are allocated
#### Stack / Stack area
-  For every thread, JVM creates one run-time stack which is stored here. Every block of this stack is called activation record/stack frame which stores methods calls. All local variables of that method are stored in their corresponding frame. After a thread terminates, its run-time stack will be destroyed by JVM. It is not a shared resource
- Java Stack stores frames. It holds local variables and partial results, and plays a part in method invocation and return.
- Each thread has a private JVM stack, created at the same time as thread.
- A new frame is created each time a method is invoked. A frame is destroyed when its method invocation completes
#### Program Counter Register
- PC (program counter) register contains the address of the Java virtual machine instruction currently being executed
#### Native Method Stack
- It contains all the native methods used in the application.
#### Execution Engine
- A virtual processor
- Interpreter: Read bytecode stream then execute the instructions.
- Just-In-Time(JIT) compiler: It is used to improve the performance. JIT compiles parts of the byte code that have similar functionality at the same time, and hence reduces the amount of time needed for compilation. Here, the term "compiler" refers to a translator from the instruction set of a Java virtual machine (JVM) to the instruction set of a specific CPU.

#### Java Native Interface
- JNI) is a framework which provides an interface to communicate with another application written in another language like C, C++, Assembly etc. Java uses JNI framework to send output to the Console or interact with OS libraries

### Spring
#### Spring CS
##### part 1
- example of initialization during the start app properties:
spring.datasource.initialization-mode = h2
spring.datasource.platform = never
files:

schema.sql
schema-${platform}.sql

command line argument to specify external file with configuration
-Dspring.config.location=your/config/dir/application.properties
logging level, loglevel, spring boot logging
java -jar myapp.jar --debug
logging:
level:
ROOT: DEBUG
-Dlogging.level.root=debug
- logging to file, log to file
  -Dlogging.file 	
  -Dlogging.path
  -Dlogging.file=deployer.log -Dlogging.path=/dev/deployer/deployer.log -Dlogging.level.root=info
  spring boot another http port, change http port, change server port
  mvn spring-boot:run -Dserver.port=8090
  spring boot start application with specific profile
  java -Dspring.profiles.active={name of profile} -jar {path to jar/war with spring-boot inside}
  spring boot update DB schema, database update, hibernate update
  -Dspring.jpa.hibernate.ddl-auto=update

- bean post processor
  @Bean public BeanPostProcessor{return new BeanPostProcessor(){}}
  application event listener
  accessible events

  @EventListener
  public void applicationPidFileWriter(ApplicationPreparedEvent event){
  ApplicationPreparedEvent surrogateEvent = new ApplicationPreparedEvent(event.getSpringApplication(), new String[]{}, event.getApplicationContext());
  new ApplicationPidFileWriter().onApplicationEvent(surrogateEvent);
  }
  default name of annotated @Bean
  class name
  name of the declared method
  to specify the name of @Bean
  @Qualifier
  using bean by name
  @Resource(name="${<name of the value>}")
- add bean programmatically, add bean at runtime
  GenericApplicationContext context = ....;
  context.registerBean("int100", Integer.class, () -> new Integer(100));
  context.registerBean("int100Lazy", Integer.class, () -> new Integer(100), (bd) -> bd.setLazyInit(true));
  hierarchy
  if @Component extends another @Component, parent won't visible for Spring context

refresh context for testing
@DirtiesContext
for starting context
@SpringBootTest instead of @BootstrapWith
spring boot actuator, spring boot list of all elements
dependency

      <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
      </dependency>
endpoints

http://localhost:8808/actuator

- health check of Spring Boot application
  <url:port>/<application>/health
  Spring Boot h2, h2 console, Spring Boot h2, conditional bean, register bean if condition is matches
  import org.h2.server.web.WebServlet;

  @Bean
  @Conditional(OpmGuiConfiguration.H2Contidion.class)
  ServletRegistrationBean h2servletRegistration(){
  ServletRegistrationBean registrationBean = new ServletRegistrationBean( new WebServlet());
  registrationBean.addUrlMappings("/h2-console/*");
  return registrationBean;
  }

  public static class H2Contidion implements Condition{
  @Override
  public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {
  return Arrays.asList(conditionContext.getEnvironment().getActiveProfiles()).contains("h2");
  }
  }
<!-- https://mvnrepository.com/artifact/com.h2database/h2 -->
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <version>1.4.197</version>
    <scope>test</scope>
</dependency>

- conditional bean, bean with specific methods
  @Bean(initMethod = "start", destroyMethod = "stop")
  @ConditionalOnMissingBean(InstanceRepository.class)
  junit test abstract file with custom copmonent scanning
  @RunWith(SpringJUnit4ClassRunner.class)
  @ContextConfiguration(loader = AnnotationConfigContextLoader.class, classes={SpringStepTest.TestConfiguration.class})
  public abstract class SpringStepTest {

  @Autowired
  ApplicationContext context;

  @Configurable
  @ComponentScan(basePackages = {"com.cd.deployer.step"})
  public static class TestConfiguration {}
  }
  not to start web application
  new SpringApplicationBuilder(CommandExecutorApplication.class).web(WebApplicationType.NONE).run(args);
- set variable from expression
  @Autowired
  JSONReader jsonReader;

  @Value("${steps}")
  String pathToSteps;
  @Value("${failSteps}")
  String pathToFailSteps;

  // Value("#{JSONReader.parse(JSONReader.readFile('${steps}'))}")
  List<StepWithParameters> steps;

  // Value("#{JSONReader.parse(JSONReader.readFile('${failSteps}'))}")
  List<StepWithParameters> failSteps;

  @PostConstruct
  public void afterBuild(){
  this.steps = jsonReader.parse(jsonReader.readFile(Objects.isNull(pathToSteps)?System.getProperty("steps"):pathToSteps));
  this.failSteps = jsonReader.parse(jsonReader.readFile(Objects.isNull(pathToFailSteps)?System.getProperty("failSteps"):pathToFailSteps));
  }



##### part 2
- Spring boot issues
  error during start standalone web application
  Unable to start web server; nested exception is org.springframework.context.ApplicationContextException:
  Unable to start ServletWebServerApplicationContext due to missing ServletWebServerFactory bean.
  just update pom.xml

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
multipart upload
"status":400,"error":"Bad Request","message":"Required request part 'file' is not present","path":"/"
application.properties

spring.servlet.multipart.max-file-size=128MB
spring.servlet.multipart.max-request-size=128MB
spring.servlet.multipart.enabled=true
No serialization found for class
HttpEntity<String> request = new HttpEntity<>(new ObjectMapper().writeValueAsString(registration), headers);
or
ObjectMapper mapper = new ObjectMapper();
mapper.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY);
HttpEntity<String> request = new HttpEntity<>(mapper.writeValueAsString(registration), headers);

- Monitoring
  Crash
  crash.sh {Process ID}
  <dependency>
  <groupId>org.crashub</groupId>
  <artifactId>crash.embed.spring</artifactId>
  <version>1.3.2</version>
  </dependency>
  <dependency>
  <groupId>org.crashub</groupId>
  <artifactId>crash.connectors.ssh</artifactId>
  <version>1.3.2</version>
  </dependency>
  <dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-remote-shell</artifactId>
  </dependency>

- spring-shell
  maven dependency
  <dependency>
  <groupId>org.springframework.shell</groupId>
  <artifactId>spring-shell-starter</artifactId>
  <version>2.0.0.RELEASE</version>
  </dependency>
  <dependency>
  <groupId>org.springframework.shell</groupId>
  <artifactId>spring-shell</artifactId>
  <version>2.0.0.RELEASE</version> 
  </dependency>
  At leas one ShellComponent MUST present !!!

import org.springframework.shell.standard.ShellComponent;
import org.springframework.shell.standard.ShellMethod;

@ShellComponent
public class HelloClass {
@ShellMethod("hello")
public String hello(){
return "jello";
}
}

skip commands
public static void main(String[] args) throws Exception {
String[] disabledCommands = {"--spring.shell.command.help.enabled=false"};
String[] fullArgs = StringUtils.concatenateStringArrays(args, disabledCommands);
SpringApplication.run(MyApp.class, fullArgs);
}


##### part 3
- skip command exit, skip close sprintshell
  String[] disabledCommands = {"--spring.shell.command.quit.enabled=false"};
  disable interactive collaboration, disable spring shell
  spring.shell.interactive.enabled=false
- spring boot maven plugin for building fat jar, uber jar, jar with all dependencies
  <plugins>
  <plugin>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-maven-plugin</artifactId>
  </plugin>
  </plugins>

- spring boot admin
  source code doc

maven dependency
<parent>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-parent</artifactId>
<version>2.0.2.RELEASE</version>
<relativePath/>
</parent>

  <dependencies>
    <dependency>
        <groupId>de.codecentric</groupId>
        <artifactId>spring-boot-admin-starter-server</artifactId>
        <version>2.0.0</version>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
  </dependencies>

- register client on server side
  @Bean
  CommandLineRunner registerClient(InstanceRegistry registry){
  return new CommandLineRunner() {
  @Override
  public void run(String... args) throws Exception {
  Registration build = Registration.builder()
  .name("sit")
  // .managementUrl("http://v337:9001/env")
  .healthUrl(    "http://v337:9001/health")
  .serviceUrl(   "http://v337:9001")
  // .source(       "http://v337:9001")
  .build();

                Mono<InstanceId> response = registry.register(build);
                System.out.println(response.block());
            }
        };
  }
  curl request to register new instance
  curl -X POST -H "content-type:application/json;charset=UTF-8" -d "@register-host.json" http://localhost:8080/instances
  {
  "name":"new host",
  "healthUrl": "http://v337:9001/health",
  "serviceUrl": "http://v337:9001",
  "metadata": {
  "version":"1"
  "controlUrl":"my-own-manager:8080"
  }
  }


##### part 4


### tomcat
####  Tomcat installation
- wget from https://tomcat.apache.org/download-80.cgi
  http port:
  file:conf/server.xml XML:Connector@port

manager application
file:conf/tomcat-users.xml should be able to be readable
file:conf/tomcat-users.xml ( manager-gui, manager-script )
#### Tomcat debug
  update file: setenv.sh

for linux:
export "JAVA_OPTS=$JAVA_OPTS -Dcatalina.log.level=INFO -Xmx1024m -Duser.timezone=UTC -Dspring.config.location=apache-tomcat-8.0.41-brandserver/conf/application-cherkavi.yml"
export CATALINA_OPTS="-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=9009 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false"
for windows:
set "JAVA_OPTS=%JAVA_OPTS% -Dcatalina.log.level=INFO -Xmx1024m -Duser.timezone=UTC -Dspring.config.location=C:\soft\tomcat\apache-tomcat-8.0.41-brandserver\conf\brand-application-cherkavi.yml"
set "CATALINA_OPTS=-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=9009 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false"






#### OPERATIONS AND SYSTEM SECURITY
- Patch and Vulnerability Management
- Least Privilege for the Tomcat Service
- Restrict Access to Tomcat Folder
  This is especially valid
  for the directories ${tomcat_home}/conf/ and ${tomcat_home}/webapps
- ADMINISTRATIVE INTERFACES
- 'Minimal Principle' Authorization Concept
  Depending on the given tasks, only rights for respective roles must be assigned. The following
  roles are available and must be assigned with minimal privileges in mind:
  ¬ manager-gui: Access to the web interface
  ¬ manager-status: Access to the “Server Status”-page only
  ¬ manager-script: Access to the script-oriented plain-text interface and “Server
  Status” page
  ¬ manager-jmx: Access to the JMX proxy interface and the “Server Status” page
- Secure Authentication
  Edit the file CATALINA_HOME/conf/server.xml and add the lockout realm with the
  following option:

<Realm className="org.apache.catalina.realm.LockOutRealm"
failureCount="5" lockOutTime="30">
</Realm>
- Open the file CATALINA_HOME/conf/server.xml. Search for the MemoryRealm and
  disable it. The JDBCRealm must also be disabled. Use the DataSourceRealm instead.
  When using a large-scale installation, do not use the UserDatabaseRealm and disable it
  as well 
- This can be done by editing the file in the CATALINA_HOME/conf/web.xml and setting the
  following configuration option:
  <session-config>
  <session-timeout>20</session-timeout>
  </session-config>
- HttpOnly can be activated with the following configuration option that must be set in
  CATALINA_BASE/conf/context.xml to be enabled globally on all applications:
  <Context useHttpOnly='true' .../>
- Cross Site Request Forgery protection in Tomcat must be enabled in order to protect
  applications. Tomcat 7 provides a basic CSRF protection. A filter can be configured in
  CATALINA_BASE/conf/web.xml globally. The filter can be overwritten by each application
  using the file WEB-INF/web.xml.
  The following configuration options must be set:
  <filter-mapping>
  <filter-name>CSRFPreventionFilter</filter-name>
  <url-pattern>/*</url-pattern>
  </filter-mapping>
- Restrict Listening Interfaces
  Edit the file CATALINA_HOME/conf/server.xml. Review every connector and specify the
  correct IP address:
  <Connector port="TCP_PORT" address="LISTEN_IP_ADDRESS"…
- Restrict Allowed Network Connections
  Open the file CATALINA_HOME/conf/server.xml and review every Connector
  configuration for the correct/desired port assignment. Remove unused ports/connectors.
- Encrypt Network Connections
  To enable SSL support, the following line can be used (the exact configuration options depend
  on the given platform and requirements) and must be placed in the
  CATALINA_HOME/conf/server.xml:
  <Connector protocol="org.apache.coyote.http11.Http11Protocol"
  port="8443" scheme="https" secure="true" SSLEnabled="true"
  sslProtocol="TLS" keystoreFile="path to keystore file"
  keystorePass="keystore password"/>
  Restriction of available SSL Ciphers by adding the ciphers attribute to the SSL Connector with
  the following cipher suites:
  <Connector ciphers="SSL_RSA_WITH_RC4_128_SHA,
  TLS_RSA_WITH_AES_128_CBC_SHA, TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
  TLS_DHE_DSS_WITH_AES_128_CBC_SHA, SSL_RSA_WITH_3DES_EDE_CBC_SHA,
  SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA,
  SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA" …
  The enforcement of SSL only communication must be done in one of the following 2 ways:
  To force the usage of HTTPS for all Web Applications hosted on the Tomcat, each securityconstraint tag within each CATALINA_HOME/webapps/$WEBAPP/WEB-INF/web.xml must
include the following lines right before the closing </security-constraint> tag:
  <user-data-constraint>
  <transport-guarantee>CONFIDENTIAL</transport-guarantee>
  <user-data-constraint>
- Secure Shutdown Port
  Edit the file CATALINA_HOME/conf/server.xml and set the shutdown passphrase:
  <Server port="8005"
  shutdown="NonDeterministicWordSoShutdownPWisNotEasyToGuess">
  If this functionality is not needed, it must be deactivated with the following option
  <Server port="-1" shutdown="SHUTDOWN">
  The local management scripts allow a shutdown of the server even if the shutdown port is
  disabled.
- Remove all default web applications from ${tomcat_home}/webapps. Standard
  applications which must be removed are ROOT, docs, examples, host-manager, and
  manager.
- Automatic deployment is controlled by the autoDeploy and deployOnStartup attributes. If both
  are false, only Contexts defined in server.xml will be deployed and any changes will require
  a Tomcat restart. To disable automatic deployment change the following lines in the
  $CATALINA_HOME/conf/server.xml file:
  autoDeploy=”false”
  deployOnStartup=”false”


#### DEFAULT SETTINGS
- The following items list default settings which must not be changed as these are considered secure by default:
 The value of allowTrace for each Connector within the server.xml is either not present or set to false.
 In all context.xml files set the privileged attribute to false unless it is required like for the manager application:
¬ <Context ... privileged=”false” />
 Ensure that the crossContext value is either not present or set to false.
Allowing crossContext creates the possibility for a malicious application to make requests to a restricted
application.
<Context ... crossContext=”false” />
 Ensure that the allowLinking value is either not present or set to false.
Allowing symbolic links creates the possibility for directory traversal and source code disclosure vulnerabilities.
<Context ... allowLinking=”false” />
 Do not allow write access for default servlet.
¬ The DefaultServlet is configured with read-only set to true in the Wweb.xml file. Changing this to false
allow clients to delete or modify static resources on the server and to upload new resources. This should
not normally be changed without requiring authentication.
 Do not enable listing
¬ The DefaultServlet is configured with listings set to false. This is not only because allowing directory
listings is considered unsafe but because generating listings of directories with thousands of files can
consume significant CPU resources, leading to a DoOS attack.
 When the RECYCLE_FACADES option is set to true, Tomcat will recycle the session facade between requests. This
will lead to information leakage between requests. By default, this parameter is not set. Ensure that the startup
script in use does not contain the following line:
¬ -Dorg.apache.catalina.connector.RECYCLE_FACADES=false
 Being able to specify different path delimiters on Tomcat gives an attacker the possibility to access applications that
were previously blocked by a proxy like mod_proxy. Per default, this parameter is not set.
¬ Ensure that the startup script in use does not contain the following line:
¬ -Dorg.apache.catalina.connector. CoyoteAdapter.ALLOW_BACKSLASH=false
¬ -Dorg.apache.tomcat.util.buf. UDecoder.ALLOW_ENCODED_SLASH=false
 Being able to specify custom header status messages enables an attacker to inject headers. This allows a potential
attack vector for Cross-Site Scripting attacks. Per default, this parameter is not set.
¬ Ensure that the startup script in use does not contain the following line:
¬ -Dorg.apache.coyote.USE_CUSTOM_STATUS_MSG_IN_HEADER=false
#### Tomcat - Cheatsheet
- How can we start Tomcat with parameter that enable remote debugging?

catalina.sh jpda start
How can we start Tomcat using another server.xml file?

catalina.sh -config /path/to/server.xml
How can we pass the -D additional parameter while starting tomcat?

We can set an environment variable (before starting tomcat):

export CATALINA_OPTS="-Dapp.username -Dapp.username"
set CATALINA_OPTS="-Dapp.username -Dapp.username"
export JAVA_OPTS="-Dapp.username -Dapp.username" // Linux
set JAVA_OPTS="-Dapp.username -Dapp.username" // Windows
We should use CATALINA_OPTS instead of JAVA_OPTS. The CATALINA_OPTS is only used by Tomcat.

How can we make a webapp hot deployable?

Add the following line to the server.xml:

<Context path="/yourContext" reloadable="true" docBase="rootFolderOfYourApp" />

- How can we enable admin or manager?

By default, Tomcat does not enable admin or manager access. To enable it, you have to edit the “%TOMCAT_FOLDER%/conf/tomcat-users.xml”.

<?xml version='1.0' encoding='utf-8'?>
<tomcat-users>
<!--
  <role rolename="tomcat"/>
  <role rolename="role1"/>
  <user username="tomcat" password="tomcat" roles="tomcat"/>
  <user username="both" password="tomcat" roles="tomcat,role1"/>
  <user username="role1" password="tomcat" roles="role1"/>
-->
  <role rolename="manager"></role>
  <role rolename="admin"/>
  <user username="admin" password="admin" roles="admin,manager"/>
</tomcat-users>
How can we configure Tomcat session timeout duration?

Locate the conf/web.xml file. Look for

<session-config>
    <session-timeout>30</session-timeout>
</session-config>
The timeout value is specified in minutes. Restart Tomcat after modifying the file, so the changes can take effect.

- How can we change the name of the session cookie?

By default, Java web applications use the cookie name JSESSIONID. If you were to integrate two separate Java applications using HTML frames, you may have a risk that your applications may get confused because it is seeing the session ID from the other application, and this session ID does not exists. If your applications are being served by different containers or servers, you may need to configure your web container to use a different name for your session cookie for each application.

The related system properties are:

org.apache.catalina.SESSION_COOKIE_NAME (for cookie name)
org.apache.catalina.SESSION_PARAMETER_NAME (for parameter name)
System property can be passed using standard methodology; use “-D” parameter of Java command similar to following.

java -D<key>=<value>
Modify catalina.sh to pass system properties:

JAVA_OPTS="$JAVA_OPTS
-Dorg.apache.catalina.SESSION_COOKIE_NAME=MYJSESSIONID
-Dorg.apache.catalina.SESSION_PARAMETER_NAME=myjsessionid"
Tomcat 7 moves this from org.apache.catalina.SESSION_COOKIE_NAME to an attribute on the main context. See http://tomcat.apache.org/migration-7.html#Session_manager_configuration

<Context path="/yourApp" sessionCookieName="custom_session_id"></Context>

- What are some of the strategies that you can use to improve your site performance?

For static content, consider using a CDN, or configure your infrastructure so that static content is routed (using the capability of your load balancer) to dedicated servers that are specifically configured and optimized to serve static contents.
Use benchmark tools to obtain a clear, comprehensive picture of your site's current performance.
Study, refactor, and benchmark your code. Before making any improvements, it is essential that you establish an accurate benchmark of your site's current performance, so that any changes can be measured in a useful, quantifiable manner. Tools that can be used to benchmark your code: Apache JMeter, ab (a benchmark tool provided by Apache).
Identify the bottlenecks in your architectures.
Consider adding more servers.
Consider adding more memory if your servers seems to be memory-bounded.
Consider using faster CPU if your servers seems to be CPU-bounded.
Consider changing your hard disk configuration such as adding a better hard disk controller, a better hard disk, using RAID or SCSI if your server seems to be IO-bounded. See http://www.staff.uni-mainz.de/neuffer/scsi/what_is_raid.html, http://computer.howstuffworks.com/scsi1.htm
Upgrade to using the latest stable JVM release.
Tune your JVM
Consider experimenting with your JVM threading configuration. If your JVM supports both green and native threads, you should try both models. If you are running IO-bound applications, native thread should offer improved performance. However, green thread will decrease the load placed on your machine. Native thread is usually a good choice.
Certains JVM processes, such as garbage collection and memory re-allocation, can be a drain on your server. You can reduce the frequency with which these processes occur by using the -Xmx and -Xms switches to control how JVM handles its heap memory.
JVM garbage collection can use up valuable CPU power. To reduce the frequency with which JVM invokes garbage collections, use the -Xmx switch to start the JVM with a higher maximum heap memory. To maximize the effectiveness of this technique, use the -Xms switch to ensure that the JVM's initial heap memory size is equal to the maximum allocated memory. This will keep Tomcat JVM from having to reallocate and resize its heap memory. If your application can handle the possibility of lower total garbage collection throughput, you should try enabling incremental collection with -Xincgc
If you need more information on the way your current configuration is handling your collection load, use the -verbose:gc to capture performance data.
Update to the latest version of Tomcat
How will configuring maxThreads Connector setting improve your site performance?

Basing your maxThreads Connector thread pool settings on an accurate estimation of your web request load is essential for getting the most out of Tomcat. Values that are too small can leave you without enough threads to handle all your requests and prevent Tomcat from effectively utilizing your server hardware. Values that are too high can significantly increase Tomcat's startup time, which is critical issue at peak traffic interval. Experiment with different values to determine the best middle ground.

How will using compression help or impact performance?

By default, compression is set to off, but some application performs better when it is switched to on. Try changing this settings and see what work best for your application. Consider using the compressableMimeTypes setting to specify what types of data you want compressed.

If we have a choice between using HTTP versus HTTPS, which one should we use?

In general, using HTTP instead of HTTPS will result in much better performance. However, HTTP may not be the right choice for your site.

What is the sequence that Tomcat uses to load Java library files during start-up?

The JVM bootstrap loader loads the core Java libraries. Incidentally, this is the one place where environment variables do matter, as the JVM locates the core libraries using the JAVA_HOME variable.
Startup.sh, calling Catalina.sh with the "start" parameter, overwrites the system classpath and loads bootstrap.jar and tomcat-juli.jar. These resources are only visible to Tomcat.
Class loaders are created for each deployed Context, which load all classes and JAR files contained in each web application's WEB-INF/classes and WEB-INF/lib, respectively and in that order. These resources are only visible to the web application that loads them.
The Common class loader loads all classes and JAR files contained in $CATALINA_HOME/lib. These resources are visible to all applications and to Tomcat.
- How can we configure Tomcat to use an external class loader?

To make Tomcat aware of an external repository, declare the file in catalina.properties under the shared loader, using the correct syntax. Syntax will vary based on the type of file or repository you are attempting to configure:

To add a folder as a class repository, use the format "path/to/foldername"
To add all JARs in a folder as class repositories, use the format: "path/to/foldername/*.jar"
To add a single JAR file as a class repository, use the following format: "file://path/to/foldername/jarname.jar"
To call environment variables, use the ${} format, i.e. ${VARIABLE_NAME}
To declare multiple resources, separate each entry with a comma.
All paths may be relative to CATALINA_BASE or CATALINA_HOME, or absolute.

If you have multiple web applications, and they all depend on a certain JAR file, what should you do?

It is best not to include additional libraries other than common 3rd party libraries such as JDBC drivers in $CATALINA_HOME/lib, even though this will work in some situations. Instead, recreate the "/shared/lib" and "/shared/classes" directories used in Tomcat 5.x, and configure them in catalina.properties by editing the shared.loader attribute:

"shared/classes,shared/lib/*.jar"
If you are embedding Tomcat inside another container, and you are having classpath issue, what should you do?

Java class loading is "lazy", which means that the first classloader that requests a certain class owns the class for the remainder of its lifecycle. If the System classloader, whose classes are not visible to the web application, loads the framework class first, the JVM will prevent additional instances of the class from being created, causing the classpath errors.

The way to get around this problem is to add a custom bootstrap classloader to your application. Configure this classloader to load the appropriate libraries on behalf of your web application, and then trigger the start-up of the rest of the application as normal. This will resolve all classloader conflicts in favor of your application.



#### 
#### 
#### 
#### 
#### 

### references
### r
- https://www.interviewbit.com/java-cheat-sheet/
- https://www.javatpoint.com/jvm-java-virtual-machine
- https://en.wikipedia.org/wiki/Java_virtual_machine#:~:text=A%20Java%20virtual%20machine%20(JVM)%20is%20a%20virtual%20machine%20that,required%20in%20a%20JVM%20implementation.
- https://dzone.com/articles/jvm-architecture-explained
- https://github.com/cherkavi/cheat-sheet/blob/master/tomcat.md
- https://github.com/cherkavi/cheat-sheet/blob/master/spring.md
- http://khaidoan.wikidot.com/tomcat-cheatsheet